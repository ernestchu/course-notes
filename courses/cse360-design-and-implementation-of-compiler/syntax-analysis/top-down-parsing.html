<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <title>Top-Down Parsing | Ernie's course notes</title><meta name="description" content="Thank you for visiting my course notes">
    <link rel="modulepreload" href="/course-notes/assets/app.bdc3a143.js"><link rel="modulepreload" href="/course-notes/assets/top-down-parsing.html.2597c177.js"><link rel="modulepreload" href="/course-notes/assets/plugin-vue_export-helper.5a098b48.js"><link rel="modulepreload" href="/course-notes/assets/top-down-parsing.html.571a9025.js">
    <link rel="stylesheet" href="/course-notes/assets/style.28fc8010.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/course-notes/" class=""><!----><span class="site-name">Ernie&#39;s course notes</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/course-notes/courses/cse350-computer-network/" class="nav-link" aria-label="CSE350 Computer Network"><!--[--><!--]--> CSE350 Computer Network <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse365-unix-system-programming/" class="nav-link" aria-label="CSE365 Unix System Programming"><!--[--><!--]--> CSE365 Unix System Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse360-design-and-implementation-of-compiler/" class="nav-link router-link-active" aria-label="CSE360 Design and Implementation of Compiler"><!--[--><!--]--> CSE360 Design and Implementation of Compiler <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse491-network-application-programming/" class="nav-link" aria-label="CSE491 Network Application Programming"><!--[--><!--]--> CSE491 Network Application Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/ernestchu/course-notes" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/course-notes/courses/cse350-computer-network/" class="nav-link" aria-label="CSE350 Computer Network"><!--[--><!--]--> CSE350 Computer Network <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse365-unix-system-programming/" class="nav-link" aria-label="CSE365 Unix System Programming"><!--[--><!--]--> CSE365 Unix System Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse360-design-and-implementation-of-compiler/" class="nav-link router-link-active" aria-label="CSE360 Design and Implementation of Compiler"><!--[--><!--]--> CSE360 Design and Implementation of Compiler <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse491-network-application-programming/" class="nav-link" aria-label="CSE491 Network Application Programming"><!--[--><!--]--> CSE491 Network Application Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/ernestchu/course-notes" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">Top-Down Parsing</p><ul class=""><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#recursive-descent-parsing" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Recursive-Descent Parsing"><!--[--><!--]--> Recursive-Descent Parsing <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#first-set" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="FIRST Set"><!--[--><!--]--> FIRST Set <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#why-first" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Why FIRST"><!--[--><!--]--> Why FIRST <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#rules-for-first-set" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Rules for FIRST set"><!--[--><!--]--> Rules for FIRST set <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#a-simple-example" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="A simple example"><!--[--><!--]--> A simple example <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#follow-set" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="FOLLOW Set"><!--[--><!--]--> FOLLOW Set <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#why-follow" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Why FOLLOW"><!--[--><!--]--> Why FOLLOW <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#rules-for-follow-set" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Rules for FOLLOW set"><!--[--><!--]--> Rules for FOLLOW set <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#a-simple-example-1" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="A simple example"><!--[--><!--]--> A simple example <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#ll-1-grammars" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="LL(1) Grammars"><!--[--><!--]--> LL(1) Grammars <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#definition-of-ll-1-grammars" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Definition of LL(1) grammars"><!--[--><!--]--> Definition of LL(1) grammars <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#nonrecursive-predictive-parsing" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Nonrecursive Predictive Parsing"><!--[--><!--]--> Nonrecursive Predictive Parsing <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#construction-of-a-predictive-parsing-table" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Construction of a predictive parsing table"><!--[--><!--]--> Construction of a predictive parsing table <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#predict-sets-and-ll-1-verification" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="PREDICT sets and LL(1) verification"><!--[--><!--]--> PREDICT sets and LL(1) verification <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#table-driven-predictive-parsing" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Table-driven predictive parsing"><!--[--><!--]--> Table-driven predictive parsing <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="top-down-parsing" tabindex="-1"><a class="header-anchor" href="#top-down-parsing" aria-hidden="true">#</a> Top-Down Parsing</h1><p>The section begins with a general form of top-down parsing, called recursive-descent parsing, which may require backtracking to find the correct $A$-production to be applied. Later we&#39;ll introduce predictive parsing, a special case of recursive-descent parsing, where <strong>no backtracking</strong> is required. Predictive parsing chooses the correct $A$-production by looking ahead at the input a fixed number of symbols, typically we may look only at one (that is, the next input symbol).</p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#recursive-descent-parsing" class="router-link-active router-link-exact-active">Recursive-Descent Parsing</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#first-set" class="router-link-active router-link-exact-active">FIRST Set</a><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#why-first" class="router-link-active router-link-exact-active">Why FIRST</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#rules-for-first-set" class="router-link-active router-link-exact-active">Rules for FIRST set</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#a-simple-example" class="router-link-active router-link-exact-active">A simple example</a></li></ul></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#follow-set" class="router-link-active router-link-exact-active">FOLLOW Set</a><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#why-follow" class="router-link-active router-link-exact-active">Why FOLLOW</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#rules-for-follow-set" class="router-link-active router-link-exact-active">Rules for FOLLOW set</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#a-simple-example-1" class="router-link-active router-link-exact-active">A simple example</a></li></ul></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#ll-1-grammars" class="router-link-active router-link-exact-active">LL(1) Grammars</a><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#definition-of-ll-1-grammars" class="router-link-active router-link-exact-active">Definition of LL(1) grammars</a></li></ul></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#nonrecursive-predictive-parsing" class="router-link-active router-link-exact-active">Nonrecursive Predictive Parsing</a><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#construction-of-a-predictive-parsing-table" class="router-link-active router-link-exact-active">Construction of a predictive parsing table</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#predict-sets-and-ll-1-verification" class="router-link-active router-link-exact-active">PREDICT sets and LL(1) verification</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.html#table-driven-predictive-parsing" class="router-link-active router-link-exact-active">Table-driven predictive parsing</a></li></ul></li></ul></nav><h2 id="recursive-descent-parsing" tabindex="-1"><a class="header-anchor" href="#recursive-descent-parsing" aria-hidden="true">#</a> Recursive-Descent Parsing</h2><p>Consider the grammar</p><p>$\begin{matrix} S &amp; \rightarrow &amp; cAd \ A &amp; \rightarrow &amp; ab ; \vert ; a \ \end{matrix}$</p><p>To construct a parse tree top-down for the input string $w = cad$, begin with the starting node $S$, and the input pointer pointing to the first character from left to right of the input, i.e., $c$.</p><ol><li>Since $S$ has only one production, we use it to expand $S$ and obtain the tree of the lhs of the figure below.</li><li>The leftmost leaf, labeled $c$, matches the first symbol of input $w$, so we advance the input pointer to $a$. Now, use the first alternative $A \rightarrow ab$ to obtain the tree of the middle of the figure below.</li><li>Since $b$ does not match $d$, we report failure and go back to $A$ and retract the input pointer to seek for another alternative producing a match. The second alternative $A -&gt; a$ produces the tree of rhs of the figure below. The leaf $a$ and $d$ match to the second and the third symbols of $w$ respectively, we halt and annouce successful completion of parsing.</li></ol><p><img src="/course-notes/assets/recursive-descent-parsing.b967756d.svg" alt="recursive-descent-parsing"></p><p>Noted that a left-recursive grammar can cause a recursive-descent parser, even one with backtracking, to go into an infinite loop. That&#39;s why we&#39;ve talked about the <a href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#elimination-of-left-recursion" class="">elimination of left recursion</a>. Also, the backtracking is not an efficient way to construct a parse tree, thus we shall see how to predict the right alternative below.</p><h2 id="first-set" tabindex="-1"><a class="header-anchor" href="#first-set" aria-hidden="true">#</a> FIRST Set</h2><h3 id="why-first" tabindex="-1"><a class="header-anchor" href="#why-first" aria-hidden="true">#</a> Why FIRST</h3><p><strong>Consider the production rule</strong></p><p>$\begin{matrix} S &amp; \rightarrow &amp; cAd \ A &amp; \rightarrow &amp; bc ; \vert ; a \ \end{matrix}$</p><p>Assume the input string is $cad$. Scanning from left to write, upon reading $c$, we know that $S \rightarrow cAd$ may be applicable but only if $A$ produces a string led by $a$. Therefore, we need to know what comes first in $A$, i.e. $FIRST \lparen A \rparen$.</p><p>In this case, $FIRST \lparen A \rparen = {b, a}$, so we can tell that $A$ is applicable and use the production rule $A \rightarrow a$ to build the following parse tree.</p><p><img src="/course-notes/assets/why-first.5d496018.svg" alt="why-first"></p><h3 id="rules-for-first-set" tabindex="-1"><a class="header-anchor" href="#rules-for-first-set" aria-hidden="true">#</a> Rules for FIRST set</h3><p>To compute $FIRST(X)$ for all grammar symbol $X$, apply the following rules until no more terminals or $\epsilon$ can be added to any FIRST set.</p><ol><li>If $X$ is a terminal, then $FIRST(X) = {X}$.</li><li>If $X$ is a nonterminal and $X \rightarrow Y_1Y_2 \cdots Y_k$ is a production for some $k\geq 1$ <ul><li>Place $a$ in $FIRST(X)$ if for some $i$, $a$ is in $FIRST(Y_i)$, and $\epsilon$ is in all of $FIRST(Y_1), \cdots , FIRST(Y_{i-1})$, i.e., $Y_1 \cdots Y_{i-1} \xRightarrow{*} \epsilon$.</li><li>Add $\epsilon$ to $FIRST(X)$ if $\epsilon$ is in $FIRST(Y_j)$ for all $j = 1, 2, \cdots ,k$.</li></ul></li><li>If $X \rightarrow \epsilon$ is a production, then add $\epsilon$ to $FIRST(X)$.</li></ol><div class="custom-container tip"><p class="custom-container-title">Elaboration on the Rules</p><ol><li>For example, suppose $A \rightarrow a ; \vert ; \lparen B \rparen$, then $FIRST(A) = { a , \lparen }$, where $a$ and $\lparen$ are terminals</li><li>For example, everything in $FIRST(Y_1)$ is surely in $FIRST(X)$. If $Y_1$ does not derive $\epsilon$, then we add nothing more to $FIRST(X)$, but if $Y_1 \xRightarrow{*} \epsilon$, then we add $FIRST(Y_2)$, and so on.</li><li>The rule should be self-explanatory.</li></ol></div><h3 id="a-simple-example" tabindex="-1"><a class="header-anchor" href="#a-simple-example" aria-hidden="true">#</a> A simple example</h3><p>Consider the production rules below</p><p>$\begin{matrix} E &amp; \rightarrow &amp; TE&#39; ;;;;;;; \ E&#39; &amp; \rightarrow &amp; +TE&#39; ; \vert ; \epsilon \ T &amp; \rightarrow &amp; FT&#39; ;;;;;;; \ T&#39; &amp; \rightarrow &amp; *FT&#39; ; \vert ; \epsilon \ F &amp; \rightarrow &amp; \lparen E \rparen ; \vert ; \textbf{id} \ \end{matrix}$</p><p>Find the FIRST sets for the nonterminals</p><div class="custom-container tip"><p class="custom-container-title">Solution</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>FIRST(F) = {(}
FIRST(F) = {(, id}

FIRST(E&#39;) = {+}
FIRST(E&#39;) = {+, ε}

FIRST(T&#39;) = {*}
FIRST(T&#39;) = {*, ε}

FIRST(T) = FIRST(F) = {(, id}
FIRST(E) = FIRST(T) = {(, id}
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><table><thead><tr><th>Nonterminal</th><th>FIRST Set</th></tr></thead><tbody><tr><td>$E$</td><td>${ \lparen , \textbf{id}}$</td></tr><tr><td>$E&#39;$</td><td>${+, \epsilon }$</td></tr><tr><td>$T$</td><td>${ \lparen , \textbf{id}}$</td></tr><tr><td>$T&#39;$</td><td>${*, \epsilon }$</td></tr><tr><td>$F$</td><td>${ \lparen , \textbf{id}}$</td></tr></tbody></table></div><h2 id="follow-set" tabindex="-1"><a class="header-anchor" href="#follow-set" aria-hidden="true">#</a> FOLLOW Set</h2><h3 id="why-follow" tabindex="-1"><a class="header-anchor" href="#why-follow" aria-hidden="true">#</a> Why FOLLOW</h3><p><strong>Consider the production rule</strong></p><p>$\begin{matrix} A &amp; \rightarrow &amp; aBb \ B &amp; \rightarrow &amp; c ; \vert ; \epsilon \ \end{matrix}$</p><p>Suppose the string to parse is $ab$. Scanning from left to write, upon reading $a$, we know that $A \rightarrow aBb$ may be applicable but only if $B$ can vanish <strong>and the character follows $B$ is $b$</strong>. That&#39;s why we need to know what follows $B$, i.e. $FOLLOW \lparen B \rparen$</p><p>In this case, $FOLLOW \lparen B \rparen = {b}$ and the current input (after scanned $a$) is $b$. Hence the parser applies this rule and generate the following parse tree</p><p><img src="/course-notes/assets/why-follow.0607f894.svg" alt="why-follow"></p><h3 id="rules-for-follow-set" tabindex="-1"><a class="header-anchor" href="#rules-for-follow-set" aria-hidden="true">#</a> Rules for FOLLOW set</h3><p>To compute $FOLLOW(A)$ for all nonterminals $A$, apply the following rules until nothing can be added to any FOLLOW set.</p><ol><li>Place $$ in $FOLLOW(S)$, where $S$ is the start symbol and $$ is the input right endmarker.</li><li>If there is a production $A \rightarrow \alpha B \beta$, then everything in $FIRST(\beta)$ except $\epsilon$ is in $FOLLOW(B)$.</li><li>If there is a production $A \rightarrow \alpha B$, or a production $A \rightarrow \alpha B \beta$, where $FIRST(\beta)$ contains $\epsilon$, then everything in $FOLLOW(A)$ is in $FOLLOW(B)$.</li></ol><h3 id="a-simple-example-1" tabindex="-1"><a class="header-anchor" href="#a-simple-example-1" aria-hidden="true">#</a> A simple example</h3><p>Continue the example above</p><p>$\begin{matrix} E &amp; \rightarrow &amp; TE&#39; ;;;;;;; \ E&#39; &amp; \rightarrow &amp; +TE&#39; ; \vert ; \epsilon \ T &amp; \rightarrow &amp; FT&#39; ;;;;;;; \ T&#39; &amp; \rightarrow &amp; *FT&#39; ; \vert ; \epsilon \ F &amp; \rightarrow &amp; \lparen E \rparen ; \vert ; \textbf{id} \ \end{matrix}$</p><table><thead><tr><th>Nonterminal</th><th>FIRST Set</th></tr></thead><tbody><tr><td>$E$</td><td>${ \lparen , \textbf{id}}$</td></tr><tr><td>$E&#39;$</td><td>${+, \epsilon }$</td></tr><tr><td>$T$</td><td>${ \lparen , \textbf{id}}$</td></tr><tr><td>$T&#39;$</td><td>${*, \epsilon }$</td></tr><tr><td>$F$</td><td>${ \lparen , \textbf{id}}$</td></tr></tbody></table><p>Find the FOLLOW sets for the nonterminals</p><div class="custom-container tip"><p class="custom-container-title">Solution</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>FOLLOW(E) = {$}
FOLLOW(E) = {$, )}

FOLLOW(E&#39;) = FOLLOW(E) = {$, )}

FOLLOW(T) = FIRST(E&#39;) - {ε} = {+}
FOLLOW(T) = {+} ∪ FOLLOW(E) = {+, $, )}

FOLLOW(T&#39;) = FOLLOW(T) = {+, $, )}

FOLLOW(F) = FIRST(T&#39;) - {ε} = {*}
FOLLOW(F) = {*} ∪ FOLLOW(T) = {*, +, $, )}

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><table><thead><tr><th>Nonterminal</th><th>FOLLOW Set</th></tr></thead><tbody><tr><td>$E$</td><td>${ \textdollar , \rparen }$</td></tr><tr><td>$E&#39;$</td><td>${ \textdollar , \rparen }$</td></tr><tr><td>$T$</td><td>${ + , \textdollar , \rparen }$</td></tr><tr><td>$T&#39;$</td><td>${ + , \textdollar , \rparen }$</td></tr><tr><td>$F$</td><td>${ * , + , \textdollar , \rparen }$</td></tr></tbody></table></div><h2 id="ll-1-grammars" tabindex="-1"><a class="header-anchor" href="#ll-1-grammars" aria-hidden="true">#</a> LL(1) Grammars</h2><p>Predictive parsers, that is, recursive-descent parsers needing no backtracking, can be constructed for a class of grammars called <strong>LL(1)</strong>.</p><ol><li>The first &quot;L&quot; in LL(1) stands for scanning the input from <strong>left to right</strong>,</li><li>The second &quot;L&quot; for producing a <strong>leftmost derivation</strong></li><li>The &quot;1&quot; for using <strong>one input</strong> symbol of lookahead at each step to make parsing action decisions.</li></ol><h3 id="definition-of-ll-1-grammars" tabindex="-1"><a class="header-anchor" href="#definition-of-ll-1-grammars" aria-hidden="true">#</a> Definition of LL(1) grammars</h3><p>A grammar $G$ is LL(1) if and only if whenever $A \rightarrow \alpha ; \vert ; \beta$ are two distinct productions of $G$, the following conditions hold:</p><ol><li>No left-recursion or ambiguity</li><li>For no terminal $a$ do both $\alpha$ and $\beta$ derive strings beginning with $a$. <ul><li>Equivalent to that $FIRST \lparen \alpha \rparen$ and $FIRST \lparen \beta \rparen$ are disjoint sets.</li></ul></li><li>At most one of $\alpha$ and $\beta$ can derive the empty string.</li><li>If $\beta \xRightarrow{*} \epsilon$, then $\alpha$ does not derive any string beginning with a terminal in $FOLLOW \lparen A \rparen$, and vice versa. <ul><li>Equivalent to that if $\epsilon$ is in $FIRST \lparen \beta \rparen$, then $FIRST \lparen \alpha \rparen$ and $FOLLOW \lparen A \rparen$ are disjoint sets, and vice versa.</li></ul></li></ol><h2 id="nonrecursive-predictive-parsing" tabindex="-1"><a class="header-anchor" href="#nonrecursive-predictive-parsing" aria-hidden="true">#</a> Nonrecursive Predictive Parsing</h2><h3 id="construction-of-a-predictive-parsing-table" tabindex="-1"><a class="header-anchor" href="#construction-of-a-predictive-parsing-table" aria-hidden="true">#</a> Construction of a predictive parsing table</h3><p>For each production $A \rightarrow \alpha$ of the grammar, do the following:</p><ol><li>For each terminal $a$ in $FIRST \lparen \alpha \rparen$, add $A \rightarrow \alpha$ to $M \lbrack A, a \rbrack$</li><li>If $\epsilon$ is in $FIRST \lparen \alpha \rparen$, then for each terminal $b$ in $FOLLOW \lparen A \rparen$, add $A \rightarrow \alpha$ to $M \lbrack A, b \rbrack$. If $\epsilon$ is in $FIRST \lparen \alpha \rparen$ and $$ is in $FOLLOW \lparen A \rparen$, add $A \rightarrow \alpha$ to $M \lbrack A, \textdollar \rbrack$ as well.</li></ol><p>Finally, set $M \lbrack A, a \rbrack$ to <strong>error</strong> if there&#39;s no production at all.</p><p>Use the same grammar above for example, but we&#39;ll use the standard BNF for a clearer view</p><p>$\begin{matrix} E &amp; \rightarrow &amp; TE&#39; \ E&#39; &amp; \rightarrow &amp; +TE&#39; \ E&#39; &amp; \rightarrow &amp; \epsilon \ T &amp; \rightarrow &amp; FT&#39; \ T&#39; &amp; \rightarrow &amp; *FT&#39; \ T&#39; &amp; \rightarrow &amp; \epsilon \ F &amp; \rightarrow &amp; \lparen E \rparen \ F &amp; \rightarrow &amp; \textbf{id} \ \end{matrix}$</p><table><thead><tr><th>Nonterminal</th><th>FIRST Set</th><th>FOLLOW Set</th></tr></thead><tbody><tr><td>$E$</td><td>${ \lparen , \textbf{id}}$</td><td>${ \textdollar , \rparen }$</td></tr><tr><td>$E&#39;$</td><td>${+, \epsilon }$</td><td>${ \textdollar , \rparen }$</td></tr><tr><td>$T$</td><td>${ \lparen , \textbf{id}}$</td><td>${ + , \textdollar , \rparen }$</td></tr><tr><td>$T&#39;$</td><td>${*, \epsilon }$</td><td>${ + , \textdollar , \rparen }$</td></tr><tr><td>$F$</td><td>${ \lparen , \textbf{id}}$</td><td>${ * , + , \textdollar , \rparen }$</td></tr></tbody></table><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>For E -&gt; TE&#39;
    1.  M[E, (]  = E -&gt; TE&#39;
        M[E, id] = E -&gt; TE&#39;

For E&#39; -&gt; +TE&#39;
    1.  M[E&#39;, +] = E&#39; -&gt; +TE&#39;

For E&#39; -&gt; ε
    2.  M[E&#39;, )] = E&#39; -&gt; ε
        M[E&#39;, $] = E&#39; -&gt; ε

For T -&gt; FT&#39;
    1.  M[T, (]  = T -&gt; FT&#39;
        M[T, id] = T -&gt; FT&#39;

For T&#39; -&gt; *FT&#39;
    1.  M[T&#39;, *] = T&#39; -&gt; *FT&#39;

For T&#39; -&gt; ε
    2.  M[T&#39;, +] = T&#39; -&gt; ε
        M[T&#39;, )] = T&#39; -&gt; ε
        M[T&#39;, $] = T&#39; -&gt; ε

For F -&gt; (E)
    1.  M[F, (]  = F -&gt; (E)

For F -&gt; id
    1.  M[F, id] = F -&gt; id
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><table><thead><tr><th></th><th>$\textbf{id}$</th><th>$+$</th><th>$*$</th><th>$\lparen$</th><th>$\rparen$</th><th>$$</th></tr></thead><tbody><tr><td>$E$</td><td>$E \rightarrow TE&#39;$</td><td></td><td></td><td>$E \rightarrow TE&#39;$</td><td></td><td></td></tr><tr><td>$E&#39;$</td><td></td><td>$E&#39; \rightarrow +TE&#39;$</td><td></td><td></td><td>$E&#39; \rightarrow \epsilon$</td><td>$E&#39; \rightarrow \epsilon$</td></tr><tr><td>$T$</td><td>$T \rightarrow FT&#39;$</td><td></td><td></td><td>$T \rightarrow FT&#39;$</td><td></td><td></td></tr><tr><td>$T&#39;$</td><td></td><td>$T&#39; \rightarrow \epsilon$</td><td>$T&#39; \rightarrow *FT&#39;$</td><td></td><td>$T&#39; \rightarrow \epsilon$</td><td>$T&#39; \rightarrow \epsilon$</td></tr><tr><td>$F$</td><td>$F \rightarrow \textbf{id}$</td><td></td><td></td><td>$F \rightarrow \lparen E \rparen$</td><td></td><td></td></tr></tbody></table><h3 id="predict-sets-and-ll-1-verification" tabindex="-1"><a class="header-anchor" href="#predict-sets-and-ll-1-verification" aria-hidden="true">#</a> PREDICT sets and LL(1) verification</h3><p>In some literature, the predictive parsing table can be viewed as <strong>PREDICT sets</strong>. For each production $A \rightarrow \alpha$ of the grammar, add $a$ into $PREDICT \lparen A \rightarrow \alpha \rparen$ if $M \lbrack A, a \rbrack$ is $A \rightarrow \alpha$.</p><table><thead><tr><th>Production</th><th>PREDICT Set</th></tr></thead><tbody><tr><td>$E \rightarrow TE&#39;$</td><td>${ \textbf{id} , \lparen }$</td></tr><tr><td>$E&#39; \rightarrow +TE&#39;$</td><td>${ + }$</td></tr><tr><td>$E&#39; \rightarrow \epsilon$</td><td>${ \rparen , \textdollar }$</td></tr><tr><td>$T \rightarrow FT&#39;$</td><td>${ \textbf{id} , \lparen }$</td></tr><tr><td>$T&#39; \rightarrow *FT&#39;$</td><td>${ * }$</td></tr><tr><td>$T&#39; \rightarrow \epsilon$</td><td>${ +, \rparen , \textdollar }$</td></tr><tr><td>$F \rightarrow \lparen E \rparen$</td><td>${ \lparen }$</td></tr><tr><td>$F \rightarrow \textbf{id}$</td><td>${ \textbf{id} }$</td></tr></tbody></table><p>We can further combine the 2<sup>nd</sup> and 4<sup>th</sup> conditions in the <a href="#definition-of-ll-1-grammars">definition of LL(1) grammars</a> into the examination of PREDICT sets. LL(1) contains exactly those grammars that have <strong>disjoint PREDICT sets</strong> for productions that share a common left-hand side. That is, at most <strong>one</strong> production can be added into each entry in the predictive parsing table $M$.</p><div class="custom-container tip"><p class="custom-container-title">Example</p><table><thead><tr><th>Production</th><th>PREDICT Set</th></tr></thead><tbody><tr><td>$E&#39; \rightarrow +TE&#39;$</td><td>${ + }$</td></tr><tr><td>$E&#39; \rightarrow \epsilon$</td><td>${ \rparen , \textdollar }$</td></tr></tbody></table><table><thead><tr><th></th><th>$\textbf{id}$</th><th>$+$</th><th>$*$</th><th>$\lparen$</th><th>$\rparen$</th><th>$$</th></tr></thead><tbody><tr><td>$E&#39;$</td><td></td><td>$E&#39; \rightarrow +TE&#39;$</td><td></td><td></td><td>$E&#39; \rightarrow \epsilon$</td><td>$E&#39; \rightarrow \epsilon$</td></tr></tbody></table><p><strong>LL(1)!</strong></p><table><thead><tr><th>Production</th><th>PREDICT Set</th></tr></thead><tbody><tr><td>$T&#39; \rightarrow *FT&#39;$</td><td>${ * }$</td></tr><tr><td>$T&#39; \rightarrow \epsilon$</td><td>${ +, \rparen , \textdollar }$</td></tr></tbody></table><table><thead><tr><th></th><th>$\textbf{id}$</th><th>$+$</th><th>$*$</th><th>$\lparen$</th><th>$\rparen$</th><th>$$</th></tr></thead><tbody><tr><td>$T&#39;$</td><td></td><td>$T&#39; \rightarrow \epsilon$</td><td>$T&#39; \rightarrow *FT&#39;$</td><td></td><td>$T&#39; \rightarrow \epsilon$</td><td>$T&#39; \rightarrow \epsilon$</td></tr></tbody></table><p><strong>LL(1)!</strong></p><table><thead><tr><th>Production</th><th>PREDICT Set</th></tr></thead><tbody><tr><td>$F \rightarrow \lparen E \rparen$</td><td>${ \lparen }$</td></tr><tr><td>$F \rightarrow \textbf{id}$</td><td>${ \textbf{id} }$</td></tr></tbody></table><table><thead><tr><th></th><th>$\textbf{id}$</th><th>$+$</th><th>$*$</th><th>$\lparen$</th><th>$\rparen$</th><th>$$</th></tr></thead><tbody><tr><td>$F$</td><td>$F \rightarrow \textbf{id}$</td><td></td><td></td><td>$F \rightarrow \lparen E \rparen$</td><td></td><td></td></tr></tbody></table><p><strong>LL(1)!</strong></p></div><h3 id="table-driven-predictive-parsing" tabindex="-1"><a class="header-anchor" href="#table-driven-predictive-parsing" aria-hidden="true">#</a> Table-driven predictive parsing</h3><p><strong>Model of a table-driven predictive parser</strong></p><p><img src="/course-notes/assets/table-driven-predictive-parser.7e4b7983.png" alt="table-driven-predictive-parser"></p><blockquote><p>Image credit to Compilers: Principles, Techniques, and Tools 2nd Edition</p></blockquote><ul><li>Input: A string $w$ and a <a href="#construction-of-a-predictive-parsing-table">parsing table</a> $M$ for grammar $G$.</li><li>Output: A leftmost derivation of $w$ or an error indication.</li></ul><p>Initially, the parser is in a configuration with $w$ in the input buffer and the start symbol $S$ of $G$ on top of the stack, above $$.</p><ul><li>Set the input pointer $ip$ to point to the first symbol of $w$</li><li>Set $X$ to the top stack symbol and while $X \neq $ do the following</li></ul><ol><li>If $X$ is $a$, pop the stack and advance $ip$. <ul><li>Else if $X$ is a terminal or $M \lbrack X, a \rbrack$ is an error entry ,error out.</li><li>Else if $M \lbrack X ,a \rbrack = X \rightarrow Y_1Y_2 \cdots Y_k$ <ol><li>Output the production $X \rightarrow Y_1Y_2 \cdots Y_k$</li><li>Pop the stack</li><li>Push $Y_k, Y_{k-1}, \cdots , Y_1$ onto the stack, with $Y_1$ on top</li></ol></li></ul></li><li>Set $X$ to the top stack symbol.</li></ol><h4 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h4><p>Continue from above</p><table><thead><tr><th></th><th>$\textbf{id}$</th><th>$+$</th><th>$*$</th><th>$\lparen$</th><th>$\rparen$</th><th>$$</th></tr></thead><tbody><tr><td>$E$</td><td>$E \rightarrow TE&#39;$</td><td></td><td></td><td>$E \rightarrow TE&#39;$</td><td></td><td></td></tr><tr><td>$E&#39;$</td><td></td><td>$E&#39; \rightarrow +TE&#39;$</td><td></td><td></td><td>$E&#39; \rightarrow \epsilon$</td><td>$E&#39; \rightarrow \epsilon$</td></tr><tr><td>$T$</td><td>$T \rightarrow FT&#39;$</td><td></td><td></td><td>$T \rightarrow FT&#39;$</td><td></td><td></td></tr><tr><td>$T&#39;$</td><td></td><td>$T&#39; \rightarrow \epsilon$</td><td>$T&#39; \rightarrow *FT&#39;$</td><td></td><td>$T&#39; \rightarrow \epsilon$</td><td>$T&#39; \rightarrow \epsilon$</td></tr><tr><td>$F$</td><td>$F \rightarrow \textbf{id}$</td><td></td><td></td><td>$F \rightarrow \lparen E \rparen$</td><td></td><td></td></tr></tbody></table><p><strong>Moves made by a predictive parser on input</strong> $\textbf{id} + \textbf{id} * \textbf{id}$</p><table><thead><tr><th>Matched</th><th>Input</th><th>Action</th><th>Stack</th></tr></thead><tbody><tr><td></td><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td></td><td>$E$</td></tr><tr><td></td><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td>output $E \rightarrow TE&#39;$</td><td>$TE&#39;$</td></tr><tr><td></td><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td>output $T \rightarrow FT&#39;$</td><td>$FT&#39;E&#39;$</td></tr><tr><td></td><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td>output $F \rightarrow \textbf{id}$</td><td>$\textbf{id} T&#39;E&#39;$</td></tr><tr><td>$\textbf{id}$</td><td>$+ \textbf{id} * \textbf{id}$</td><td>match $\textbf{id}$</td><td>$T&#39;E&#39;$</td></tr><tr><td>$\textbf{id}$</td><td>$+ \textbf{id} * \textbf{id}$</td><td>output $T&#39; \rightarrow \epsilon$</td><td>$E&#39;$</td></tr><tr><td>$\textbf{id}$</td><td>$+ \textbf{id} * \textbf{id}$</td><td>output $E&#39; \rightarrow +TE&#39;$</td><td>$+TE&#39;$</td></tr><tr><td>$\textbf{id} +$</td><td>$\textbf{id} * \textbf{id}$</td><td>match $+$</td><td>$TE&#39;$</td></tr><tr><td>$\textbf{id} +$</td><td>$\textbf{id} * \textbf{id}$</td><td>output $T \rightarrow FT&#39;$</td><td>$FT&#39;E&#39;$</td></tr><tr><td>$\textbf{id} +$</td><td>$\textbf{id} * \textbf{id}$</td><td>output $F \rightarrow \textbf{id}$</td><td>$\textbf{id} T&#39;E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id}$</td><td>$* \textbf{id}$</td><td>match $\textbf{id}$</td><td>$T&#39;E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id}$</td><td>$* \textbf{id}$</td><td>output $T&#39; \rightarrow *FT&#39;$</td><td>$\textbf{id} *FT&#39;E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id} *$</td><td>$\textbf{id}$</td><td>match $*$</td><td>$FT&#39;E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id} *$</td><td>$\textbf{id}$</td><td>output $F \rightarrow \textbf{id}$</td><td>$\textbf{id} T&#39;E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td>$$</td><td>match $\textbf{id}$</td><td>$T&#39;E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td>$$</td><td>output $T&#39; \rightarrow \epsilon$</td><td>$E&#39;$</td></tr><tr><td>$\textbf{id} + \textbf{id} * \textbf{id}$</td><td>$$</td><td>output $E&#39; \rightarrow \epsilon$</td><td>$$</td></tr></tbody></table><p><img src="/course-notes/assets/predictive-parsing.64f5e57b.svg" alt="predictive-parsing"></p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="nav-link external meta-item-label" href="https://github.com/ernestchu/course-notes/edit/main/docs/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/top-down-parsing.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub"><!--[--><!--]--> Edit this page on GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">11/10/2021, 6:05:16 PM</span></div><div class="meta-item contributors"><span class="meta-item-label">Authors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: b073040018@nsysu.edu.tw">ernestchu</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/course-notes/assets/app.bdc3a143.js" defer></script>
  </body>
</html>
