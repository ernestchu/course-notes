<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <title>Writing a Grammar | Ernie's course notes</title><meta name="description" content="Thank you for visiting my course notes">
    <link rel="modulepreload" href="/course-notes/assets/app.bdc3a143.js"><link rel="modulepreload" href="/course-notes/assets/writing-a-grammar.html.a485edd0.js"><link rel="modulepreload" href="/course-notes/assets/plugin-vue_export-helper.5a098b48.js"><link rel="modulepreload" href="/course-notes/assets/writing-a-grammar.html.ef3119b2.js">
    <link rel="stylesheet" href="/course-notes/assets/style.28fc8010.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/course-notes/" class=""><!----><span class="site-name">Ernie&#39;s course notes</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/course-notes/courses/cse350-computer-network/" class="nav-link" aria-label="CSE350 Computer Network"><!--[--><!--]--> CSE350 Computer Network <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse365-unix-system-programming/" class="nav-link" aria-label="CSE365 Unix System Programming"><!--[--><!--]--> CSE365 Unix System Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse360-design-and-implementation-of-compiler/" class="nav-link router-link-active" aria-label="CSE360 Design and Implementation of Compiler"><!--[--><!--]--> CSE360 Design and Implementation of Compiler <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse491-network-application-programming/" class="nav-link" aria-label="CSE491 Network Application Programming"><!--[--><!--]--> CSE491 Network Application Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/ernestchu/course-notes" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/course-notes/courses/cse350-computer-network/" class="nav-link" aria-label="CSE350 Computer Network"><!--[--><!--]--> CSE350 Computer Network <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse365-unix-system-programming/" class="nav-link" aria-label="CSE365 Unix System Programming"><!--[--><!--]--> CSE365 Unix System Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse360-design-and-implementation-of-compiler/" class="nav-link router-link-active" aria-label="CSE360 Design and Implementation of Compiler"><!--[--><!--]--> CSE360 Design and Implementation of Compiler <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/course-notes/courses/cse491-network-application-programming/" class="nav-link" aria-label="CSE491 Network Application Programming"><!--[--><!--]--> CSE491 Network Application Programming <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/ernestchu/course-notes" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">Writing a Grammar</p><ul class=""><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#lexical-versus-syntactic-analysis" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Lexical Versus Syntactic Analysis"><!--[--><!--]--> Lexical Versus Syntactic Analysis <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#eliminating-ambiguity" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Eliminating Ambiguity"><!--[--><!--]--> Eliminating Ambiguity <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#elimination-of-left-recursion" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Elimination of Left Recursion"><!--[--><!--]--> Elimination of Left Recursion <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#a-simple-left-recursion" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="A simple left recursion"><!--[--><!--]--> A simple left recursion <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#the-general-case" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="The general case"><!--[--><!--]--> The general case <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#left-factoring" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Left Factoring"><!--[--><!--]--> Left Factoring <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#left-factoring-conditional-statement" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Left factoring conditional statement"><!--[--><!--]--> Left factoring conditional statement <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="writing-a-grammar" tabindex="-1"><a class="header-anchor" href="#writing-a-grammar" aria-hidden="true">#</a> Writing a Grammar</h1><p>This section begins with a discussion of how to divide work between a lexical analyzer and a parser. We then consider several transformations that could be applied to get a grammar more suitable for parsing. One technique can <strong>eliminate ambiguity</strong> in the grammar, and other techniques, <strong>left-recursion elimination</strong> and <strong>left factoring</strong>, are useful for rewriting grammars so they become suitable for <strong>top-down parsing</strong>.</p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#lexical-versus-syntactic-analysis" class="router-link-active router-link-exact-active">Lexical Versus Syntactic Analysis</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#eliminating-ambiguity" class="router-link-active router-link-exact-active">Eliminating Ambiguity</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#elimination-of-left-recursion" class="router-link-active router-link-exact-active">Elimination of Left Recursion</a><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#a-simple-left-recursion" class="router-link-active router-link-exact-active">A simple left recursion</a></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#the-general-case" class="router-link-active router-link-exact-active">The general case</a></li></ul></li><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#left-factoring" class="router-link-active router-link-exact-active">Left Factoring</a><ul><li><a aria-current="page" href="/course-notes/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#left-factoring-conditional-statement" class="router-link-active router-link-exact-active">Left factoring conditional statement</a></li></ul></li></ul></nav><h2 id="lexical-versus-syntactic-analysis" tabindex="-1"><a class="header-anchor" href="#lexical-versus-syntactic-analysis" aria-hidden="true">#</a> Lexical Versus Syntactic Analysis</h2><p>We typically use <strong>regular expressions</strong> to construct <strong>lexical analyzers</strong> while using <strong>grammars</strong> to construct <strong>parsers</strong>. In fact, everything that can be described by a regular expression can also be described by a grammar. We may ask, why use regular expressions to define the lexical syntax. There are several reasons:</p><ol><li>The lexical rules of a language are frequently quite simple, and to describe them we do not need a notation as powerful as grammars.</li><li>Regular expressions generally provide a more concise and easier-to-understand notation for tokens than grammars.</li></ol><h2 id="eliminating-ambiguity" tabindex="-1"><a class="header-anchor" href="#eliminating-ambiguity" aria-hidden="true">#</a> Eliminating Ambiguity</h2><p>Sometimes an ambiguous grammar can be rewritten to eliminate the ambiguity. As an example, we shall eliminate the ambiguity from the following &quot;dangling-else&quot; grammar:</p><p>$\begin{matrix} \textit{stmt} &amp; \rightarrow &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{stmt} ;;;;;;;;;;;;;;;; \ &amp; \vert &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{stmt} ; \textbf{else} ; \textit{stmt} \ &amp; \vert &amp; \textbf{other} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ \end{matrix}$ (1)</p><p>Here $other$ stands for any other statement. According to this grammar, the compound conditional statement</p><p>$\textbf{if} ; E_1 ; \textbf{then} ; \textbf{if} ; E_2 ; \textbf{then} ; S_1 ; \textbf{else} ; S_2$</p><p>is an example showing Grammar (1) is ambiguous since it has two parse trees</p><p><img src="/course-notes/assets/ambiguity-1.702004a9.svg" alt="ambiguity-1"><img src="/course-notes/assets/ambiguity-2.822d2d09.svg" alt="ambiguity-2"></p><p>In all programming languages with conditional statements of this form, the <strong>first</strong> parse tree is preferred. The general rule is, Match each $\textbf{else}$ with the <strong>closest</strong> unmatched $\textbf{then}$. This disambiguating rule can be incorporated directly into a grammar by using the following observations.</p><ul><li>A statement appearing between a $\textbf{then}$ and a $\textbf{else}$ must be matched ($\textbf{if-then-else}$ pairs).</li><li>Thus statements must split into kinds: $\textit{matched}$ and $\textit{unmatched}$.</li><li>The unambiguous grammar for $\textbf{if-then-else}$ statements can be described as</li></ul><p>$\begin{matrix} \textit{stmt} &amp; \rightarrow &amp; \textit{matched_stmt} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ &amp; \vert &amp; \textit{unmatched_stmt} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ \textit{matched_stmt} &amp; \rightarrow &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{matched_stmt} ; \textbf{else} ; \textit{matched_stmt} ;;; \ &amp; \vert &amp; \textbf{other} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ \textit{unmatched_stmt} &amp; \rightarrow &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{stmt} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ &amp; \vert &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{matched_stmt} ; \textbf{else} ; \textit{unmatched_stmt} \ \end{matrix}$</p><h2 id="elimination-of-left-recursion" tabindex="-1"><a class="header-anchor" href="#elimination-of-left-recursion" aria-hidden="true">#</a> Elimination of Left Recursion</h2><p>A grammar is <em>left recursive</em> if it has a nonterminal $A$ such that there is a derivation $A \xRightarrow{+} A \alpha$ for some string $\alpha$. Top-down parsing methods cannot handle left-recursive grammars, so a transformation is needed to eliminate left recursion.</p><h3 id="a-simple-left-recursion" tabindex="-1"><a class="header-anchor" href="#a-simple-left-recursion" aria-hidden="true">#</a> A simple left recursion</h3><p>The left-recursive production $A \rightarrow A \alpha \vert \beta$ could be replaced by non-left-recursive productions without changing the strings derivable from $A$.</p><p>$\begin{matrix} A &amp; \rightarrow &amp; \beta A&#39; ;; \ A&#39; &amp; \rightarrow &amp; \alpha A&#39; ; \vert ; \epsilon \ \end{matrix}$</p><h4 id="exercise" tabindex="-1"><a class="header-anchor" href="#exercise" aria-hidden="true">#</a> Exercise</h4><p>Consider the following grammar for arithmetic expressions.</p><p>$\begin{matrix} E &amp; \rightarrow &amp; E + T ; \vert ; T \ T &amp; \rightarrow &amp; T * F ; \vert ; F \ F &amp; \rightarrow &amp; \lparen E \rparen ; \vert ; \textbf{id} ;;; \ \end{matrix}$</p><p>Eliminating the immediate left recursion (production of the form $A \xRightarrow{+} A \alpha$) to the production for E and then for T.</p><div class="custom-container tip"><p class="custom-container-title">Solution</p><p>$E \rightarrow E + T ; \vert ; T$ are replaced by</p><p>$\begin{matrix} E &amp; \rightarrow &amp; TE&#39; ;;;;;; \ E&#39; &amp; \rightarrow &amp; +TE&#39; ; \vert ; \epsilon \ \end{matrix}$</p><p>$T \rightarrow T * F ; \vert ; F$ are replaced by</p><p>$\begin{matrix} T &amp; \rightarrow &amp; FT&#39; ;;;;;; \ T&#39; &amp; \rightarrow &amp; *FT&#39; ; \vert ; \epsilon \ \end{matrix}$</p></div><h3 id="the-general-case" tabindex="-1"><a class="header-anchor" href="#the-general-case" aria-hidden="true">#</a> The general case</h3><p>Here, we shall deduce the general form for this formula. Immediate left recursion can be eliminated by the following technique, which works for any number of $A$-productions. First, group the productions as</p><p>$A \rightarrow A \alpha_1 ; \vert ; A \alpha_2 ; \vert ; \cdots ; \vert ; A \alpha_m ; \vert ; \beta_1 ; \vert ; \beta_2 ; \vert ; \cdots ; \vert ; \beta_n$</p><p>where no $\beta_i$ begins with an $A$. Then replace the $A$-productions by</p><p>$\begin{matrix} A &amp; \rightarrow &amp; \beta_1 A&#39; ; \vert ; \beta_2 A&#39; ; \vert ; \cdots ; \vert ; \beta_n A&#39; ;;;;;; \ A&#39; &amp; \rightarrow &amp; \alpha_1 A&#39; ; \vert ; \alpha_2 A&#39; ; \vert ; \cdots ; \vert ; \alpha_m A&#39; ; \vert ; \epsilon \ \end{matrix}$</p><p>This eliminates all immediate left recursion, but it doesn&#39;t eliminate left recursion involving derivations of two ore more steps (not immediate). For example</p><p>$\begin{matrix} S &amp; \rightarrow &amp; Aa ; \vert ; b ;;;;;;; \ A &amp; \rightarrow &amp; Ac ; \vert ; Sd ; \vert ; \epsilon \ \end{matrix}$ (2)</p><p>The nonterminal $S$ is left recursive because $S \Rightarrow Aa \Rightarrow Sda$ but it is not immediately left recursive. Hence it can not be eliminate by the above technique. But still, in some cases we can try to handle it by the substitution. The second production in the grammar (2) becomes</p><p>$A \rightarrow Ac ; \vert ; Aad ; \vert ; bd ; \vert ; \epsilon$</p><p>Eliminating the immediate left recursion among these $A$-productions yields the following grammar.</p><p>$\begin{matrix} S &amp; \rightarrow &amp; Aa ; \vert ; b ;;;;;;;;;;; \ A &amp; \rightarrow &amp; bdA&#39; ; \vert ; A&#39; ;;;;;; \ A&#39; &amp; \rightarrow &amp; cA&#39; ; \vert ; adA&#39; ; \vert ; \epsilon \ \end{matrix}$</p><h2 id="left-factoring" tabindex="-1"><a class="header-anchor" href="#left-factoring" aria-hidden="true">#</a> Left Factoring</h2><p>Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive, or top-down, parsing. When the choice between two alternative $A$-productions is not clear, we may be able to rewrite the productions to defer the decision until enough of the input has been seen that we can make the right choice.</p><p>For example, if we have the two productions</p><p>(1) $\begin{matrix} \textit{stmt} &amp; \rightarrow &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{stmt} ;;;;;;;;;;;;;;;; \ &amp; \vert &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{stmt} ; \textbf{else} ; \textit{stmt} \ &amp; \vert &amp; \textbf{other} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ \end{matrix}$</p><p>on seeing the input token $\textbf{if}$, we cannot immediately tell which production to choose to expand $\textit{stmt}$. In general, suppose a grammar $A \rightarrow \alpha \beta_1 ; \vert ; \alpha \beta_2 ; \vert ; \cdots ; \vert ; \alpha \beta_n ; \vert ; \gamma$ where $\gamma$ represents all alternatives that do not begin with $\alpha$, and the input begin with a nonempty string derived from $\alpha$, we do not know which production to use.</p><p>However, we may defer the decision by changing the grammar into</p><p>$\begin{matrix} A &amp; \rightarrow &amp; \alpha A&#39; ; \vert ; \gamma ;;;;;;;;;;;;;; \ A&#39; &amp; \rightarrow &amp; \beta_1 ; \vert ; \beta_2 ; \vert ; \cdots ; \vert ; \beta_n \ \end{matrix}$</p><p>Here $A&#39;$ is a new nonterminal. Repeatedly apply this transformation until no two alternatives for a nonterminal have a common prefix.</p><h3 id="left-factoring-conditional-statement" tabindex="-1"><a class="header-anchor" href="#left-factoring-conditional-statement" aria-hidden="true">#</a> Left factoring conditional statement</h3><p>The grammar (1) becomes</p><p>$\begin{matrix} \textit{stmt} &amp; \rightarrow &amp; \textbf{if} ; \textit{expr} ; \textbf{then} ; \textit{stmt} ; \textit{stmt&#39;} ; \vert ; \textbf{other} \ \textit{stmt&#39;} &amp; \rightarrow &amp; \textbf{else} ; \textit{stmt} ; \vert ; \epsilon ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \ \end{matrix}$</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="nav-link external meta-item-label" href="https://github.com/ernestchu/course-notes/edit/main/docs/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub"><!--[--><!--]--> Edit this page on GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">11/10/2021, 6:05:16 PM</span></div><div class="meta-item contributors"><span class="meta-item-label">Authors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: b073040018@nsysu.edu.tw">ernestchu</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/course-notes/assets/app.bdc3a143.js" defer></script>
  </body>
</html>
