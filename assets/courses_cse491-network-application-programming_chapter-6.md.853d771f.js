import{_ as e,c as t,o as r,b as n}from"./app.eea76462.js";const f=JSON.parse('{"title":"Design of Server Software","description":"","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"Iterative Servers","slug":"iterative-servers","link":"#iterative-servers","children":[{"level":3,"title":"Connectionless server","slug":"connectionless-server","link":"#connectionless-server","children":[]},{"level":3,"title":"Connection-oriented","slug":"connection-oriented","link":"#connection-oriented","children":[]}]},{"level":2,"title":"Concurrent Servers","slug":"concurrent-servers","link":"#concurrent-servers","children":[{"level":3,"title":"Connectionless server","slug":"connectionless-server-1","link":"#connectionless-server-1","children":[]},{"level":3,"title":"Connection-oriented server","slug":"connection-oriented-server","link":"#connection-oriented-server","children":[]}]},{"level":2,"title":"Advanced Issues","slug":"advanced-issues","link":"#advanced-issues","children":[{"level":3,"title":"Create a new process","slug":"create-a-new-process","link":"#create-a-new-process","children":[]},{"level":3,"title":"Use only one thread to achieve concurrency","slug":"use-only-one-thread-to-achieve-concurrency","link":"#use-only-one-thread-to-achieve-concurrency","children":[]},{"level":3,"title":"Guidelines to select different types of servers","slug":"guidelines-to-select-different-types-of-servers","link":"#guidelines-to-select-different-types-of-servers","children":[]},{"level":3,"title":"Deadlock","slug":"deadlock","link":"#deadlock","children":[]}]},{"level":2,"title":"Example of Iterative Servers","slug":"example-of-iterative-servers","link":"#example-of-iterative-servers","children":[]}],"relativePath":"courses/cse491-network-application-programming/chapter-6.md"}'),i={name:"courses/cse491-network-application-programming/chapter-6.md"},o=n('<h1 id="design-of-server-software" tabindex="-1">Design of Server Software <a class="header-anchor" href="#design-of-server-software" aria-hidden="true">#</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-hidden="true">#</a></h2><p>Conceptually, a as server follows a simple algorithm</p><ol><li>Create and bind a socket to a well-known port</li><li>Enter an infinite loop <ul><li>Accept the next request from a client</li><li>Process the request and reply the result to client</li></ul></li></ol><p>Types of servers</p><table><thead><tr><th></th><th>Iterative</th><th>Concurrent</th></tr></thead><tbody><tr><td>Connectionless</td><td>Iterative connectionless servers</td><td>Iterative connection-oriented servers</td></tr><tr><td>Connection-oriented</td><td>Concurrent connectionless servers <strong>(rarely used)</strong></td><td>Concurrent connection-oriented servers</td></tr></tbody></table><h2 id="iterative-servers" tabindex="-1">Iterative Servers <a class="header-anchor" href="#iterative-servers" aria-hidden="true">#</a></h2><h3 id="connectionless-server" tabindex="-1">Connectionless server <a class="header-anchor" href="#connectionless-server" aria-hidden="true">#</a></h3><ol><li>Create and bind a socket to a well-known port</li><li>Enter an infinite loop <ul><li>Accept the next request from a client</li><li>Process the request and reply the result to client</li></ul></li></ol><p>The server only procides one single socket. Server can use <code>sendto()</code> and <code>recvfrom()</code> to get the address information of clients.</p><h3 id="connection-oriented" tabindex="-1">Connection-oriented <a class="header-anchor" href="#connection-oriented" aria-hidden="true">#</a></h3><ol><li>Create and bind a socket to a well-known port</li><li>Place the socket in passive mode by calling <code>listen()</code></li><li>Accept the next connection and obtain a new socket for the connection</li><li>Enter an infinite loop <ul><li>Accept the next request from a client</li><li>Process the request and reply the result to client</li></ul></li><li>When finishing with a client, close the connection and reutrn to step 3 to accept a new connection</li></ol><h2 id="concurrent-servers" tabindex="-1">Concurrent Servers <a class="header-anchor" href="#concurrent-servers" aria-hidden="true">#</a></h2><p>Concurrency reduces response time for multiple clients under serveral conditions</p><ul><li>Siginificant I/O exists</li><li>Processing time varies dramatically among requests <ul><li>Small processes don&#39;t have to wait for big processes to finish</li></ul></li><li>Computer with multiple processors</li></ul><p>Most concurrent server use multiple processes (or threads) tp achieve concurrency</p><ul><li>A single process (called mastser) begins execution initially</li><li>The master process then <ol><li>Open a socekt at the well-know port</li><li>Wait for the next request</li><li>Create a slave to handle each request</li></ol></li><li>Each slave process handles communication with one client. Once the client disconnectm the slave process exits</li></ul><h3 id="connectionless-server-1" tabindex="-1">Connectionless server <a class="header-anchor" href="#connectionless-server-1" aria-hidden="true">#</a></h3><p><strong>Master algorithm</strong></p><ol><li>Create and bind the socket to a well-known port</li><li>Reapeatedly call <code>recvfrom()</code> to receive the next request from a client and create a new slave processs (or thread) to handle that response</li></ol><p><strong>Slave algorithm</strong></p><ol><li>Access to the corresponding socket</li><li>Form a reply and send it to the client using <code>sendto()</code></li><li>Exit when finish</li></ol><div class="warning custom-block"><p class="custom-block-title">Cost of Concurrency</p><p>The cost of concurrency could be greater than the gain in speed in connectionless server. So very few connectionless server enforce a concurrent algorithm</p></div><h3 id="connection-oriented-server" tabindex="-1">Connection-oriented server <a class="header-anchor" href="#connection-oriented-server" aria-hidden="true">#</a></h3><p><strong>Master algorithm</strong></p><ol><li>Create and bind a socket to a well-known port</li><li>Place the socket in passive mode</li><li>Repeatedly call <code>accept()</code> to receive the next request and create a new slave process to handle the response</li></ol><p><strong>Slave algorithm</strong></p><ol><li>Begin with a connection passed from the master</li><li>Interact with client</li><li>Close the connection and exit</li></ol><h2 id="advanced-issues" tabindex="-1">Advanced Issues <a class="header-anchor" href="#advanced-issues" aria-hidden="true">#</a></h2><h3 id="create-a-new-process" tabindex="-1">Create a new process <a class="header-anchor" href="#create-a-new-process" aria-hidden="true">#</a></h3><h3 id="use-only-one-thread-to-achieve-concurrency" tabindex="-1">Use only one thread to achieve concurrency <a class="header-anchor" href="#use-only-one-thread-to-achieve-concurrency" aria-hidden="true">#</a></h3><h3 id="guidelines-to-select-different-types-of-servers" tabindex="-1">Guidelines to select different types of servers <a class="header-anchor" href="#guidelines-to-select-different-types-of-servers" aria-hidden="true">#</a></h3><h3 id="deadlock" tabindex="-1">Deadlock <a class="header-anchor" href="#deadlock" aria-hidden="true">#</a></h3><h2 id="example-of-iterative-servers" tabindex="-1">Example of Iterative Servers <a class="header-anchor" href="#example-of-iterative-servers" aria-hidden="true">#</a></h2>',34),s=[o];function l(a,c,d,h,u,v){return r(),t("div",null,s)}const g=e(i,[["render",l]]);export{f as __pageData,g as default};
