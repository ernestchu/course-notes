import{r as a,c as i,a as t,b as e,w as r,F as o,d as l,o as s}from"./app.bdc3a143.js";import{_ as d}from"./plugin-vue_export-helper.5a098b48.js";var $="/course-notes/assets/recursive-descent-parsing.b967756d.svg",u="/course-notes/assets/why-first.5d496018.svg",h="/course-notes/assets/why-follow.0607f894.svg",c="/course-notes/assets/table-driven-predictive-parser.7e4b7983.png",p="/course-notes/assets/predictive-parsing.64f5e57b.svg";const b={},f=t("h1",{id:"top-down-parsing",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#top-down-parsing","aria-hidden":"true"},"#"),l(" Top-Down Parsing")],-1),g=t("p",null,[l("The section begins with a general form of top-down parsing, called recursive-descent parsing, which may require backtracking to find the correct $A$-production to be applied. Later we'll introduce predictive parsing, a special case of recursive-descent parsing, where "),t("strong",null,"no backtracking"),l(" is required. Predictive parsing chooses the correct $A$-production by looking ahead at the input a fixed number of symbols, typically we may look only at one (that is, the next input symbol).")],-1),m={class:"table-of-contents"},_=l("Recursive-Descent Parsing"),T=l("FIRST Set"),w=l("Why FIRST"),x=l("Rules for FIRST set"),F=l("A simple example"),E=l("FOLLOW Set"),v=l("Why FOLLOW"),L=l("Rules for FOLLOW set"),S=l("A simple example"),y=l("LL(1) Grammars"),I=l("Definition of LL(1) grammars"),R=l("Nonrecursive Predictive Parsing"),O=l("Construction of a predictive parsing table"),k=l("PREDICT sets and LL(1) verification"),A=l("Table-driven predictive parsing"),W=t("h2",{id:"recursive-descent-parsing",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#recursive-descent-parsing","aria-hidden":"true"},"#"),l(" Recursive-Descent Parsing")],-1),P=t("p",null,"Consider the grammar",-1),M=t("p",null,"$$\\begin{matrix} S & \\rightarrow & cAd \\ A & \\rightarrow & ab ; \\vert ; a \\ \\end{matrix}$$",-1),Y=t("p",null,"To construct a parse tree top-down for the input string $w = cad$, begin with the starting node $S$, and the input pointer pointing to the first character from left to right of the input, i.e., $c$.",-1),X=t("ol",null,[t("li",null,"Since $S$ has only one production, we use it to expand $S$ and obtain the tree of the lhs of the figure below."),t("li",null,"The leftmost leaf, labeled $c$, matches the first symbol of input $w$, so we advance the input pointer to $a$. Now, use the first alternative $A \\rightarrow ab$ to obtain the tree of the middle of the figure below."),t("li",null,"Since $b$ does not match $d$, we report failure and go back to $A$ and retract the input pointer to seek for another alternative producing a match. The second alternative $A -> a$ produces the tree of rhs of the figure below. The leaf $a$ and $d$ match to the second and the third symbols of $w$ respectively, we halt and annouce successful completion of parsing.")],-1),C=t("p",null,[t("img",{src:$,alt:"recursive-descent-parsing"})],-1),B=l("Noted that a left-recursive grammar can cause a recursive-descent parser, even one with backtracking, to go into an infinite loop. That's why we've talked about the "),D=l("elimination of left recursion"),N=l(". Also, the backtracking is not an efficient way to construct a parse tree, thus we shall see how to predict the right alternative below."),q=t("h2",{id:"first-set",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#first-set","aria-hidden":"true"},"#"),l(" FIRST Set")],-1),j=t("h3",{id:"why-first",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#why-first","aria-hidden":"true"},"#"),l(" Why FIRST")],-1),G=t("p",null,[t("strong",null,"Consider the production rule")],-1),V=t("p",null,"$$\\begin{matrix} S & \\rightarrow & cAd \\ A & \\rightarrow & bc ; \\vert ; a \\ \\end{matrix}$$",-1),H=t("p",null,"Assume the input string is $cad$. Scanning from left to write, upon reading $c$, we know that $S \\rightarrow cAd$ may be applicable but only if $A$ produces a string led by $a$. Therefore, we need to know what comes first in $A$, i.e. $FIRST \\lparen A \\rparen$.",-1),U=t("p",null,"In this case, $FIRST \\lparen A \\rparen = {b, a}$, so we can tell that $A$ is applicable and use the production rule $A \\rightarrow a$ to build the following parse tree.",-1),z=t("p",null,[t("img",{src:u,alt:"why-first"})],-1),J=t("h3",{id:"rules-for-first-set",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#rules-for-first-set","aria-hidden":"true"},"#"),l(" Rules for FIRST set")],-1),K=t("p",null,"To compute $FIRST(X)$ for all grammar symbol $X$, apply the following rules until no more terminals or $\\epsilon$ can be added to any FIRST set.",-1),Q=t("ol",null,[t("li",null,"If $X$ is a terminal, then $FIRST(X) = {X}$."),t("li",null,[l("If $X$ is a nonterminal and $X \\rightarrow Y_1Y_2 \\cdots Y_k$ is a production for some $k\\geq 1$ "),t("ul",null,[t("li",null,"Place $a$ in $FIRST(X)$ if for some $i$, $a$ is in $FIRST(Y_i)$, and $\\epsilon$ is in all of $FIRST(Y_1), \\cdots , FIRST(Y_{i-1})$, i.e., $Y_1 \\cdots Y_{i-1} \\xRightarrow{*} \\epsilon$."),t("li",null,"Add $\\epsilon$ to $FIRST(X)$ if $\\epsilon$ is in $FIRST(Y_j)$ for all $j = 1, 2, \\cdots ,k$.")])]),t("li",null,"If $X \\rightarrow \\epsilon$ is a production, then add $\\epsilon$ to $FIRST(X)$.")],-1),Z=t("div",{class:"custom-container tip"},[t("p",{class:"custom-container-title"},"Elaboration on the Rules"),t("ol",null,[t("li",null,"For example, suppose $A \\rightarrow a ; \\vert ; \\lparen B \\rparen$, then $FIRST(A) = { a , \\lparen }$, where $a$ and $\\lparen$ are terminals"),t("li",null,"For example, everything in $FIRST(Y_1)$ is surely in $FIRST(X)$. If $Y_1$ does not derive $\\epsilon$, then we add nothing more to $FIRST(X)$, but if $Y_1 \\xRightarrow{*} \\epsilon$, then we add $FIRST(Y_2)$, and so on."),t("li",null,"The rule should be self-explanatory.")])],-1),tt=t("h3",{id:"a-simple-example",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#a-simple-example","aria-hidden":"true"},"#"),l(" A simple example")],-1),lt=t("p",null,"Consider the production rules below",-1),nt=t("p",null,"$$\\begin{matrix} E & \\rightarrow & TE' ;;;;;;; \\ E' & \\rightarrow & +TE' ; \\vert ; \\epsilon \\ T & \\rightarrow & FT' ;;;;;;; \\ T' & \\rightarrow & *FT' ; \\vert ; \\epsilon \\ F & \\rightarrow & \\lparen E \\rparen ; \\vert ; \\textbf{id} \\ \\end{matrix}$$",-1),et=t("p",null,"Find the FIRST sets for the nonterminals",-1),rt=t("div",{class:"custom-container tip"},[t("p",{class:"custom-container-title"},"Solution"),t("div",{class:"language-text ext-text line-numbers-mode"},[t("pre",{class:"language-text"},[t("code",null,`FIRST(F) = {(}
FIRST(F) = {(, id}

FIRST(E') = {+}
FIRST(E') = {+, \u03B5}

FIRST(T') = {*}
FIRST(T') = {*, \u03B5}

FIRST(T) = FIRST(F) = {(, id}
FIRST(E) = FIRST(T) = {(, id}
`)]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br")])]),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Nonterminal"),t("th",null,"FIRST Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E$"),t("td",null,"${ \\lparen , \\textbf{id}}$")]),t("tr",null,[t("td",null,"$E'$"),t("td",null,"${+, \\epsilon }$")]),t("tr",null,[t("td",null,"$T$"),t("td",null,"${ \\lparen , \\textbf{id}}$")]),t("tr",null,[t("td",null,"$T'$"),t("td",null,"${*, \\epsilon }$")]),t("tr",null,[t("td",null,"$F$"),t("td",null,"${ \\lparen , \\textbf{id}}$")])])])],-1),at=t("h2",{id:"follow-set",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#follow-set","aria-hidden":"true"},"#"),l(" FOLLOW Set")],-1),it=t("h3",{id:"why-follow",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#why-follow","aria-hidden":"true"},"#"),l(" Why FOLLOW")],-1),ot=t("p",null,[t("strong",null,"Consider the production rule")],-1),st=t("p",null,"$$\\begin{matrix} A & \\rightarrow & aBb \\ B & \\rightarrow & c ; \\vert ; \\epsilon \\ \\end{matrix}$$",-1),dt=t("p",null,[l("Suppose the string to parse is $ab$. Scanning from left to write, upon reading $a$, we know that $A \\rightarrow aBb$ may be applicable but only if $B$ can vanish "),t("strong",null,"and the character follows $B$ is $b$"),l(". That's why we need to know what follows $B$, i.e. $FOLLOW \\lparen B \\rparen$")],-1),$t=t("p",null,"In this case, $FOLLOW \\lparen B \\rparen = {b}$ and the current input (after scanned $a$) is $b$. Hence the parser applies this rule and generate the following parse tree",-1),ut=t("p",null,[t("img",{src:h,alt:"why-follow"})],-1),ht=t("h3",{id:"rules-for-follow-set",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#rules-for-follow-set","aria-hidden":"true"},"#"),l(" Rules for FOLLOW set")],-1),ct=t("p",null,"To compute $FOLLOW(A)$ for all nonterminals $A$, apply the following rules until nothing can be added to any FOLLOW set.",-1),pt=t("ol",null,[t("li",null,"Place $$$ in $FOLLOW(S)$, where $S$ is the start symbol and $$$ is the input right endmarker."),t("li",null,"If there is a production $A \\rightarrow \\alpha B \\beta$, then everything in $FIRST(\\beta)$ except $\\epsilon$ is in $FOLLOW(B)$."),t("li",null,"If there is a production $A \\rightarrow \\alpha B$, or a production $A \\rightarrow \\alpha B \\beta$, where $FIRST(\\beta)$ contains $\\epsilon$, then everything in $FOLLOW(A)$ is in $FOLLOW(B)$.")],-1),bt=t("h3",{id:"a-simple-example-1",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#a-simple-example-1","aria-hidden":"true"},"#"),l(" A simple example")],-1),ft=t("p",null,"Continue the example above",-1),gt=t("p",null,"$$\\begin{matrix} E & \\rightarrow & TE' ;;;;;;; \\ E' & \\rightarrow & +TE' ; \\vert ; \\epsilon \\ T & \\rightarrow & FT' ;;;;;;; \\ T' & \\rightarrow & *FT' ; \\vert ; \\epsilon \\ F & \\rightarrow & \\lparen E \\rparen ; \\vert ; \\textbf{id} \\ \\end{matrix}$$",-1),mt=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Nonterminal"),t("th",null,"FIRST Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E$"),t("td",null,"${ \\lparen , \\textbf{id}}$")]),t("tr",null,[t("td",null,"$E'$"),t("td",null,"${+, \\epsilon }$")]),t("tr",null,[t("td",null,"$T$"),t("td",null,"${ \\lparen , \\textbf{id}}$")]),t("tr",null,[t("td",null,"$T'$"),t("td",null,"${*, \\epsilon }$")]),t("tr",null,[t("td",null,"$F$"),t("td",null,"${ \\lparen , \\textbf{id}}$")])])],-1),_t=t("p",null,"Find the FOLLOW sets for the nonterminals",-1),Tt=t("div",{class:"custom-container tip"},[t("p",{class:"custom-container-title"},"Solution"),t("div",{class:"language-text ext-text line-numbers-mode"},[t("pre",{class:"language-text"},[t("code",null,`FOLLOW(E) = {$}
FOLLOW(E) = {$, )}

FOLLOW(E') = FOLLOW(E) = {$, )}

FOLLOW(T) = FIRST(E') - {\u03B5} = {+}
FOLLOW(T) = {+} \u222A FOLLOW(E) = {+, $, )}

FOLLOW(T') = FOLLOW(T) = {+, $, )}

FOLLOW(F) = FIRST(T') - {\u03B5} = {*}
FOLLOW(F) = {*} \u222A FOLLOW(T) = {*, +, $, )}

`)]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br"),t("span",{class:"line-number"},"12"),t("br"),t("span",{class:"line-number"},"13"),t("br")])]),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Nonterminal"),t("th",null,"FOLLOW Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E$"),t("td",null,"${ \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$E'$"),t("td",null,"${ \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$T$"),t("td",null,"${ + , \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$T'$"),t("td",null,"${ + , \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$F$"),t("td",null,"${ * , + , \\textdollar , \\rparen }$")])])])],-1),wt=t("h2",{id:"ll-1-grammars",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#ll-1-grammars","aria-hidden":"true"},"#"),l(" LL(1) Grammars")],-1),xt=t("p",null,[l("Predictive parsers, that is, recursive-descent parsers needing no backtracking, can be constructed for a class of grammars called "),t("strong",null,"LL(1)"),l(".")],-1),Ft=t("ol",null,[t("li",null,[l('The first "L" in LL(1) stands for scanning the input from '),t("strong",null,"left to right"),l(",")]),t("li",null,[l('The second "L" for producing a '),t("strong",null,"leftmost derivation")]),t("li",null,[l('The "1" for using '),t("strong",null,"one input"),l(" symbol of lookahead at each step to make parsing action decisions.")])],-1),Et=t("h3",{id:"definition-of-ll-1-grammars",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#definition-of-ll-1-grammars","aria-hidden":"true"},"#"),l(" Definition of LL(1) grammars")],-1),vt=t("p",null,"A grammar $G$ is LL(1) if and only if whenever $A \\rightarrow \\alpha ; \\vert ; \\beta$ are two distinct productions of $G$, the following conditions hold:",-1),Lt=t("ol",null,[t("li",null,"No left-recursion or ambiguity"),t("li",null,[l("For no terminal $a$ do both $\\alpha$ and $\\beta$ derive strings beginning with $a$. "),t("ul",null,[t("li",null,"Equivalent to that $FIRST \\lparen \\alpha \\rparen$ and $FIRST \\lparen \\beta \\rparen$ are disjoint sets.")])]),t("li",null,"At most one of $\\alpha$ and $\\beta$ can derive the empty string."),t("li",null,[l("If $\\beta \\xRightarrow{*} \\epsilon$, then $\\alpha$ does not derive any string beginning with a terminal in $FOLLOW \\lparen A \\rparen$, and vice versa. "),t("ul",null,[t("li",null,"Equivalent to that if $\\epsilon$ is in $FIRST \\lparen \\beta \\rparen$, then $FIRST \\lparen \\alpha \\rparen$ and $FOLLOW \\lparen A \\rparen$ are disjoint sets, and vice versa.")])])],-1),St=t("h2",{id:"nonrecursive-predictive-parsing",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#nonrecursive-predictive-parsing","aria-hidden":"true"},"#"),l(" Nonrecursive Predictive Parsing")],-1),yt=t("h3",{id:"construction-of-a-predictive-parsing-table",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#construction-of-a-predictive-parsing-table","aria-hidden":"true"},"#"),l(" Construction of a predictive parsing table")],-1),It=t("p",null,"For each production $A \\rightarrow \\alpha$ of the grammar, do the following:",-1),Rt=t("ol",null,[t("li",null,"For each terminal $a$ in $FIRST \\lparen \\alpha \\rparen$, add $A \\rightarrow \\alpha$ to $M \\lbrack A, a \\rbrack$"),t("li",null,"If $\\epsilon$ is in $FIRST \\lparen \\alpha \\rparen$, then for each terminal $b$ in $FOLLOW \\lparen A \\rparen$, add $A \\rightarrow \\alpha$ to $M \\lbrack A, b \\rbrack$. If $\\epsilon$ is in $FIRST \\lparen \\alpha \\rparen$ and $$$ is in $FOLLOW \\lparen A \\rparen$, add $A \\rightarrow \\alpha$ to $M \\lbrack A, \\textdollar \\rbrack$ as well.")],-1),Ot=t("p",null,[l("Finally, set $M \\lbrack A, a \\rbrack$ to "),t("strong",null,"error"),l(" if there's no production at all.")],-1),kt=t("p",null,"Use the same grammar above for example, but we'll use the standard BNF for a clearer view",-1),At=t("p",null,"$$\\begin{matrix} E & \\rightarrow & TE' \\ E' & \\rightarrow & +TE' \\ E' & \\rightarrow & \\epsilon \\ T & \\rightarrow & FT' \\ T' & \\rightarrow & *FT' \\ T' & \\rightarrow & \\epsilon \\ F & \\rightarrow & \\lparen E \\rparen \\ F & \\rightarrow & \\textbf{id} \\ \\end{matrix}$$",-1),Wt=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Nonterminal"),t("th",null,"FIRST Set"),t("th",null,"FOLLOW Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E$"),t("td",null,"${ \\lparen , \\textbf{id}}$"),t("td",null,"${ \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$E'$"),t("td",null,"${+, \\epsilon }$"),t("td",null,"${ \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$T$"),t("td",null,"${ \\lparen , \\textbf{id}}$"),t("td",null,"${ + , \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$T'$"),t("td",null,"${*, \\epsilon }$"),t("td",null,"${ + , \\textdollar , \\rparen }$")]),t("tr",null,[t("td",null,"$F$"),t("td",null,"${ \\lparen , \\textbf{id}}$"),t("td",null,"${ * , + , \\textdollar , \\rparen }$")])])],-1),Pt=t("div",{class:"language-text ext-text line-numbers-mode"},[t("pre",{class:"language-text"},[t("code",null,`For E -> TE'
    1.  M[E, (]  = E -> TE'
        M[E, id] = E -> TE'

For E' -> +TE'
    1.  M[E', +] = E' -> +TE'

For E' -> \u03B5
    2.  M[E', )] = E' -> \u03B5
        M[E', $] = E' -> \u03B5

For T -> FT'
    1.  M[T, (]  = T -> FT'
        M[T, id] = T -> FT'

For T' -> *FT'
    1.  M[T', *] = T' -> *FT'

For T' -> \u03B5
    2.  M[T', +] = T' -> \u03B5
        M[T', )] = T' -> \u03B5
        M[T', $] = T' -> \u03B5

For F -> (E)
    1.  M[F, (]  = F -> (E)

For F -> id
    1.  M[F, id] = F -> id
`)]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br"),t("span",{class:"line-number"},"12"),t("br"),t("span",{class:"line-number"},"13"),t("br"),t("span",{class:"line-number"},"14"),t("br"),t("span",{class:"line-number"},"15"),t("br"),t("span",{class:"line-number"},"16"),t("br"),t("span",{class:"line-number"},"17"),t("br"),t("span",{class:"line-number"},"18"),t("br"),t("span",{class:"line-number"},"19"),t("br"),t("span",{class:"line-number"},"20"),t("br"),t("span",{class:"line-number"},"21"),t("br"),t("span",{class:"line-number"},"22"),t("br"),t("span",{class:"line-number"},"23"),t("br"),t("span",{class:"line-number"},"24"),t("br"),t("span",{class:"line-number"},"25"),t("br"),t("span",{class:"line-number"},"26"),t("br"),t("span",{class:"line-number"},"27"),t("br"),t("span",{class:"line-number"},"28"),t("br")])],-1),Mt=t("table",null,[t("thead",null,[t("tr",null,[t("th"),t("th",null,"$\\textbf{id}$"),t("th",null,"$+$"),t("th",null,"$*$"),t("th",null,"$\\lparen$"),t("th",null,"$\\rparen$"),t("th",null,"$$$")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E$"),t("td",null,"$E \\rightarrow TE'$"),t("td"),t("td"),t("td",null,"$E \\rightarrow TE'$"),t("td"),t("td")]),t("tr",null,[t("td",null,"$E'$"),t("td"),t("td",null,"$E' \\rightarrow +TE'$"),t("td"),t("td"),t("td",null,"$E' \\rightarrow \\epsilon$"),t("td",null,"$E' \\rightarrow \\epsilon$")]),t("tr",null,[t("td",null,"$T$"),t("td",null,"$T \\rightarrow FT'$"),t("td"),t("td"),t("td",null,"$T \\rightarrow FT'$"),t("td"),t("td")]),t("tr",null,[t("td",null,"$T'$"),t("td"),t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"$T' \\rightarrow *FT'$"),t("td"),t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"$T' \\rightarrow \\epsilon$")]),t("tr",null,[t("td",null,"$F$"),t("td",null,"$F \\rightarrow \\textbf{id}$"),t("td"),t("td"),t("td",null,"$F \\rightarrow \\lparen E \\rparen$"),t("td"),t("td")])])],-1),Yt=t("h3",{id:"predict-sets-and-ll-1-verification",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#predict-sets-and-ll-1-verification","aria-hidden":"true"},"#"),l(" PREDICT sets and LL(1) verification")],-1),Xt=t("p",null,[l("In some literature, the predictive parsing table can be viewed as "),t("strong",null,"PREDICT sets"),l(". For each production $A \\rightarrow \\alpha$ of the grammar, add $a$ into $PREDICT \\lparen A \\rightarrow \\alpha \\rparen$ if $M \\lbrack A, a \\rbrack$ is $A \\rightarrow \\alpha$.")],-1),Ct=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Production"),t("th",null,"PREDICT Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E \\rightarrow TE'$"),t("td",null,"${ \\textbf{id} , \\lparen }$")]),t("tr",null,[t("td",null,"$E' \\rightarrow +TE'$"),t("td",null,"${ + }$")]),t("tr",null,[t("td",null,"$E' \\rightarrow \\epsilon$"),t("td",null,"${ \\rparen , \\textdollar }$")]),t("tr",null,[t("td",null,"$T \\rightarrow FT'$"),t("td",null,"${ \\textbf{id} , \\lparen }$")]),t("tr",null,[t("td",null,"$T' \\rightarrow *FT'$"),t("td",null,"${ * }$")]),t("tr",null,[t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"${ +, \\rparen , \\textdollar }$")]),t("tr",null,[t("td",null,"$F \\rightarrow \\lparen E \\rparen$"),t("td",null,"${ \\lparen }$")]),t("tr",null,[t("td",null,"$F \\rightarrow \\textbf{id}$"),t("td",null,"${ \\textbf{id} }$")])])],-1),Bt=t("p",null,[l("We can further combine the 2"),t("sup",null,"nd"),l(" and 4"),t("sup",null,"th"),l(" conditions in the "),t("a",{href:"#definition-of-ll-1-grammars"},"definition of LL(1) grammars"),l(" into the examination of PREDICT sets. LL(1) contains exactly those grammars that have "),t("strong",null,"disjoint PREDICT sets"),l(" for productions that share a common left-hand side. That is, at most "),t("strong",null,"one"),l(" production can be added into each entry in the predictive parsing table $M$.")],-1),Dt=t("div",{class:"custom-container tip"},[t("p",{class:"custom-container-title"},"Example"),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Production"),t("th",null,"PREDICT Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E' \\rightarrow +TE'$"),t("td",null,"${ + }$")]),t("tr",null,[t("td",null,"$E' \\rightarrow \\epsilon$"),t("td",null,"${ \\rparen , \\textdollar }$")])])]),t("table",null,[t("thead",null,[t("tr",null,[t("th"),t("th",null,"$\\textbf{id}$"),t("th",null,"$+$"),t("th",null,"$*$"),t("th",null,"$\\lparen$"),t("th",null,"$\\rparen$"),t("th",null,"$$$")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E'$"),t("td"),t("td",null,"$E' \\rightarrow +TE'$"),t("td"),t("td"),t("td",null,"$E' \\rightarrow \\epsilon$"),t("td",null,"$E' \\rightarrow \\epsilon$")])])]),t("p",null,[t("strong",null,"LL(1)!")]),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Production"),t("th",null,"PREDICT Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$T' \\rightarrow *FT'$"),t("td",null,"${ * }$")]),t("tr",null,[t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"${ +, \\rparen , \\textdollar }$")])])]),t("table",null,[t("thead",null,[t("tr",null,[t("th"),t("th",null,"$\\textbf{id}$"),t("th",null,"$+$"),t("th",null,"$*$"),t("th",null,"$\\lparen$"),t("th",null,"$\\rparen$"),t("th",null,"$$$")])]),t("tbody",null,[t("tr",null,[t("td",null,"$T'$"),t("td"),t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"$T' \\rightarrow *FT'$"),t("td"),t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"$T' \\rightarrow \\epsilon$")])])]),t("p",null,[t("strong",null,"LL(1)!")]),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Production"),t("th",null,"PREDICT Set")])]),t("tbody",null,[t("tr",null,[t("td",null,"$F \\rightarrow \\lparen E \\rparen$"),t("td",null,"${ \\lparen }$")]),t("tr",null,[t("td",null,"$F \\rightarrow \\textbf{id}$"),t("td",null,"${ \\textbf{id} }$")])])]),t("table",null,[t("thead",null,[t("tr",null,[t("th"),t("th",null,"$\\textbf{id}$"),t("th",null,"$+$"),t("th",null,"$*$"),t("th",null,"$\\lparen$"),t("th",null,"$\\rparen$"),t("th",null,"$$$")])]),t("tbody",null,[t("tr",null,[t("td",null,"$F$"),t("td",null,"$F \\rightarrow \\textbf{id}$"),t("td"),t("td"),t("td",null,"$F \\rightarrow \\lparen E \\rparen$"),t("td"),t("td")])])]),t("p",null,[t("strong",null,"LL(1)!")])],-1),Nt=t("h3",{id:"table-driven-predictive-parsing",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#table-driven-predictive-parsing","aria-hidden":"true"},"#"),l(" Table-driven predictive parsing")],-1),qt=t("p",null,[t("strong",null,"Model of a table-driven predictive parser")],-1),jt=t("p",null,[t("img",{src:c,alt:"table-driven-predictive-parser"})],-1),Gt=t("blockquote",null,[t("p",null,"Image credit to Compilers: Principles, Techniques, and Tools 2nd Edition")],-1),Vt=t("ul",null,[t("li",null,[l("Input: A string $w$ and a "),t("a",{href:"#construction-of-a-predictive-parsing-table"},"parsing table"),l(" $M$ for grammar $G$.")]),t("li",null,"Output: A leftmost derivation of $w$ or an error indication.")],-1),Ht=t("p",null,"Initially, the parser is in a configuration with $w$$ in the input buffer and the start symbol $S$ of $G$ on top of the stack, above $$$.",-1),Ut=t("ul",null,[t("li",null,"Set the input pointer $ip$ to point to the first symbol of $w$"),t("li",null,"Set $X$ to the top stack symbol and while $X \\neq $$ do the following")],-1),zt=t("ol",null,[t("li",null,[l("If $X$ is $a$, pop the stack and advance $ip$. "),t("ul",null,[t("li",null,"Else if $X$ is a terminal or $M \\lbrack X, a \\rbrack$ is an error entry ,error out."),t("li",null,[l("Else if $M \\lbrack X ,a \\rbrack = X \\rightarrow Y_1Y_2 \\cdots Y_k$ "),t("ol",null,[t("li",null,"Output the production $X \\rightarrow Y_1Y_2 \\cdots Y_k$"),t("li",null,"Pop the stack"),t("li",null,"Push $Y_k, Y_{k-1}, \\cdots , Y_1$ onto the stack, with $Y_1$ on top")])])])]),t("li",null,"Set $X$ to the top stack symbol.")],-1),Jt=t("h4",{id:"example",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#example","aria-hidden":"true"},"#"),l(" Example")],-1),Kt=t("p",null,"Continue from above",-1),Qt=t("table",null,[t("thead",null,[t("tr",null,[t("th"),t("th",null,"$\\textbf{id}$"),t("th",null,"$+$"),t("th",null,"$*$"),t("th",null,"$\\lparen$"),t("th",null,"$\\rparen$"),t("th",null,"$$$")])]),t("tbody",null,[t("tr",null,[t("td",null,"$E$"),t("td",null,"$E \\rightarrow TE'$"),t("td"),t("td"),t("td",null,"$E \\rightarrow TE'$"),t("td"),t("td")]),t("tr",null,[t("td",null,"$E'$"),t("td"),t("td",null,"$E' \\rightarrow +TE'$"),t("td"),t("td"),t("td",null,"$E' \\rightarrow \\epsilon$"),t("td",null,"$E' \\rightarrow \\epsilon$")]),t("tr",null,[t("td",null,"$T$"),t("td",null,"$T \\rightarrow FT'$"),t("td"),t("td"),t("td",null,"$T \\rightarrow FT'$"),t("td"),t("td")]),t("tr",null,[t("td",null,"$T'$"),t("td"),t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"$T' \\rightarrow *FT'$"),t("td"),t("td",null,"$T' \\rightarrow \\epsilon$"),t("td",null,"$T' \\rightarrow \\epsilon$")]),t("tr",null,[t("td",null,"$F$"),t("td",null,"$F \\rightarrow \\textbf{id}$"),t("td"),t("td"),t("td",null,"$F \\rightarrow \\lparen E \\rparen$"),t("td"),t("td")])])],-1),Zt=t("p",null,[t("strong",null,"Moves made by a predictive parser on input"),l(" $\\textbf{id} + \\textbf{id} * \\textbf{id}$")],-1),tl=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Matched"),t("th",null,"Input"),t("th",null,"Action"),t("th",null,"Stack")])]),t("tbody",null,[t("tr",null,[t("td"),t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$$"),t("td"),t("td",null,"$E$$")]),t("tr",null,[t("td"),t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$$"),t("td",null,"output $E \\rightarrow TE'$"),t("td",null,"$TE'$$")]),t("tr",null,[t("td"),t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$$"),t("td",null,"output $T \\rightarrow FT'$"),t("td",null,"$FT'E'$$")]),t("tr",null,[t("td"),t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$$"),t("td",null,"output $F \\rightarrow \\textbf{id}$"),t("td",null,"$\\textbf{id} T'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id}$"),t("td",null,"$+ \\textbf{id} * \\textbf{id}$$"),t("td",null,"match $\\textbf{id}$"),t("td",null,"$T'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id}$"),t("td",null,"$+ \\textbf{id} * \\textbf{id}$$"),t("td",null,"output $T' \\rightarrow \\epsilon$"),t("td",null,"$E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id}$"),t("td",null,"$+ \\textbf{id} * \\textbf{id}$$"),t("td",null,"output $E' \\rightarrow +TE'$"),t("td",null,"$+TE'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} +$"),t("td",null,"$\\textbf{id} * \\textbf{id}$$"),t("td",null,"match $+$"),t("td",null,"$TE'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} +$"),t("td",null,"$\\textbf{id} * \\textbf{id}$$"),t("td",null,"output $T \\rightarrow FT'$"),t("td",null,"$FT'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} +$"),t("td",null,"$\\textbf{id} * \\textbf{id}$$"),t("td",null,"output $F \\rightarrow \\textbf{id}$"),t("td",null,"$\\textbf{id} T'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id}$"),t("td",null,"$* \\textbf{id}$$"),t("td",null,"match $\\textbf{id}$"),t("td",null,"$T'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id}$"),t("td",null,"$* \\textbf{id}$$"),t("td",null,"output $T' \\rightarrow *FT'$"),t("td",null,"$\\textbf{id} *FT'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id} *$"),t("td",null,"$\\textbf{id}$$"),t("td",null,"match $*$"),t("td",null,"$FT'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id} *$"),t("td",null,"$\\textbf{id}$$"),t("td",null,"output $F \\rightarrow \\textbf{id}$"),t("td",null,"$\\textbf{id} T'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$"),t("td",null,"$$$"),t("td",null,"match $\\textbf{id}$"),t("td",null,"$T'E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$"),t("td",null,"$$$"),t("td",null,"output $T' \\rightarrow \\epsilon$"),t("td",null,"$E'$$")]),t("tr",null,[t("td",null,"$\\textbf{id} + \\textbf{id} * \\textbf{id}$"),t("td",null,"$$$"),t("td",null,"output $E' \\rightarrow \\epsilon$"),t("td",null,"$$$")])])],-1),ll=t("p",null,[t("img",{src:p,alt:"predictive-parsing"})],-1);function nl(el,rl){const n=a("RouterLink");return s(),i(o,null,[f,g,t("nav",m,[t("ul",null,[t("li",null,[e(n,{to:"#recursive-descent-parsing"},{default:r(()=>[_]),_:1})]),t("li",null,[e(n,{to:"#first-set"},{default:r(()=>[T]),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#why-first"},{default:r(()=>[w]),_:1})]),t("li",null,[e(n,{to:"#rules-for-first-set"},{default:r(()=>[x]),_:1})]),t("li",null,[e(n,{to:"#a-simple-example"},{default:r(()=>[F]),_:1})])])]),t("li",null,[e(n,{to:"#follow-set"},{default:r(()=>[E]),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#why-follow"},{default:r(()=>[v]),_:1})]),t("li",null,[e(n,{to:"#rules-for-follow-set"},{default:r(()=>[L]),_:1})]),t("li",null,[e(n,{to:"#a-simple-example-1"},{default:r(()=>[S]),_:1})])])]),t("li",null,[e(n,{to:"#ll-1-grammars"},{default:r(()=>[y]),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#definition-of-ll-1-grammars"},{default:r(()=>[I]),_:1})])])]),t("li",null,[e(n,{to:"#nonrecursive-predictive-parsing"},{default:r(()=>[R]),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#construction-of-a-predictive-parsing-table"},{default:r(()=>[O]),_:1})]),t("li",null,[e(n,{to:"#predict-sets-and-ll-1-verification"},{default:r(()=>[k]),_:1})]),t("li",null,[e(n,{to:"#table-driven-predictive-parsing"},{default:r(()=>[A]),_:1})])])])])]),W,P,M,Y,X,C,t("p",null,[B,e(n,{to:"/courses/cse360-design-and-implementation-of-compiler/syntax-analysis/writing-a-grammar.html#elimination-of-left-recursion"},{default:r(()=>[D]),_:1}),N]),q,j,G,V,H,U,z,J,K,Q,Z,tt,lt,nt,et,rt,at,it,ot,st,dt,$t,ut,ht,ct,pt,bt,ft,gt,mt,_t,Tt,wt,xt,Ft,Et,vt,Lt,St,yt,It,Rt,Ot,kt,At,Wt,Pt,Mt,Yt,Xt,Ct,Bt,Dt,Nt,qt,jt,Gt,Vt,Ht,Ut,zt,Jt,Kt,Qt,Zt,tl,ll],64)}var ol=d(b,[["render",nl]]);export{ol as default};
