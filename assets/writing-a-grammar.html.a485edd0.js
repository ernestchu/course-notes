import{r as n,c as o,a as t,b as a,w as r,F as s,d as e,o as l}from"./app.bdc3a143.js";import{_ as h}from"./plugin-vue_export-helper.5a098b48.js";var c="/course-notes/assets/ambiguity-1.702004a9.svg",d="/course-notes/assets/ambiguity-2.822d2d09.svg";const m={},u=t("h1",{id:"writing-a-grammar",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#writing-a-grammar","aria-hidden":"true"},"#"),e(" Writing a Grammar")],-1),g=t("p",null,[e("This section begins with a discussion of how to divide work between a lexical analyzer and a parser. We then consider several transformations that could be applied to get a grammar more suitable for parsing. One technique can "),t("strong",null,"eliminate ambiguity"),e(" in the grammar, and other techniques, "),t("strong",null,"left-recursion elimination"),e(" and "),t("strong",null,"left factoring"),e(", are useful for rewriting grammars so they become suitable for "),t("strong",null,"top-down parsing"),e(".")],-1),f={class:"table-of-contents"},_=e("Lexical Versus Syntactic Analysis"),p=e("Eliminating Ambiguity"),b=e("Elimination of Left Recursion"),x=e("A simple left recursion"),$=e("The general case"),w=e("Left Factoring"),v=e("Left factoring conditional statement"),A=t("h2",{id:"lexical-versus-syntactic-analysis",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#lexical-versus-syntactic-analysis","aria-hidden":"true"},"#"),e(" Lexical Versus Syntactic Analysis")],-1),y=t("p",null,[e("We typically use "),t("strong",null,"regular expressions"),e(" to construct "),t("strong",null,"lexical analyzers"),e(" while using "),t("strong",null,"grammars"),e(" to construct "),t("strong",null,"parsers"),e(". In fact, everything that can be described by a regular expression can also be described by a grammar. We may ask, why use regular expressions to define the lexical syntax. There are several reasons:")],-1),T=t("ol",null,[t("li",null,"The lexical rules of a language are frequently quite simple, and to describe them we do not need a notation as powerful as grammars."),t("li",null,"Regular expressions generally provide a more concise and easier-to-understand notation for tokens than grammars.")],-1),E=t("h2",{id:"eliminating-ambiguity",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#eliminating-ambiguity","aria-hidden":"true"},"#"),e(" Eliminating Ambiguity")],-1),F=t("p",null,'Sometimes an ambiguous grammar can be rewritten to eliminate the ambiguity. As an example, we shall eliminate the ambiguity from the following "dangling-else" grammar:',-1),k=t("p",null,"$$\\begin{matrix} \\textit{stmt} & \\rightarrow & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{stmt} ;;;;;;;;;;;;;;;; \\ & \\vert & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{stmt} ; \\textbf{else} ; \\textit{stmt} \\ & \\vert & \\textbf{other} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ \\end{matrix}$$ (1)",-1),S=t("p",null,"Here $other$ stands for any other statement. According to this grammar, the compound conditional statement",-1),L=t("p",null,"$$\\textbf{if} ; E_1 ; \\textbf{then} ; \\textbf{if} ; E_2 ; \\textbf{then} ; S_1 ; \\textbf{else} ; S_2$$",-1),R=t("p",null,"is an example showing Grammar (1) is ambiguous since it has two parse trees",-1),q=t("p",null,[t("img",{src:c,alt:"ambiguity-1"}),t("img",{src:d,alt:"ambiguity-2"})],-1),H=t("p",null,[e("In all programming languages with conditional statements of this form, the "),t("strong",null,"first"),e(" parse tree is preferred. The general rule is, Match each $\\textbf{else}$ with the "),t("strong",null,"closest"),e(" unmatched $\\textbf{then}$. This disambiguating rule can be incorporated directly into a grammar by using the following observations.")],-1),V=t("ul",null,[t("li",null,"A statement appearing between a $\\textbf{then}$ and a $\\textbf{else}$ must be matched ($\\textbf{if-then-else}$ pairs)."),t("li",null,"Thus statements must split into kinds: $\\textit{matched}$ and $\\textit{unmatched}$."),t("li",null,"The unambiguous grammar for $\\textbf{if-then-else}$ statements can be described as")],-1),W=t("p",null,"$$\\begin{matrix} \\textit{stmt} & \\rightarrow & \\textit{matched_stmt} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ & \\vert & \\textit{unmatched_stmt} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ \\textit{matched_stmt} & \\rightarrow & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{matched_stmt} ; \\textbf{else} ; \\textit{matched_stmt} ;;; \\ & \\vert & \\textbf{other} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ \\textit{unmatched_stmt} & \\rightarrow & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{stmt} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ & \\vert & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{matched_stmt} ; \\textbf{else} ; \\textit{unmatched_stmt} \\ \\end{matrix}$$",-1),B=t("h2",{id:"elimination-of-left-recursion",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#elimination-of-left-recursion","aria-hidden":"true"},"#"),e(" Elimination of Left Recursion")],-1),I=t("p",null,[e("A grammar is "),t("em",null,"left recursive"),e(" if it has a nonterminal $A$ such that there is a derivation $A \\xRightarrow{+} A \\alpha$ for some string $\\alpha$. Top-down parsing methods cannot handle left-recursive grammars, so a transformation is needed to eliminate left recursion.")],-1),C=t("h3",{id:"a-simple-left-recursion",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#a-simple-left-recursion","aria-hidden":"true"},"#"),e(" A simple left recursion")],-1),G=t("p",null,"The left-recursive production $A \\rightarrow A \\alpha \\vert \\beta$ could be replaced by non-left-recursive productions without changing the strings derivable from $A$.",-1),N=t("p",null,"$$\\begin{matrix} A & \\rightarrow & \\beta A' ;; \\ A' & \\rightarrow & \\alpha A' ; \\vert ; \\epsilon \\ \\end{matrix}$$",-1),j=t("h4",{id:"exercise",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#exercise","aria-hidden":"true"},"#"),e(" Exercise")],-1),z=t("p",null,"Consider the following grammar for arithmetic expressions.",-1),M=t("p",null,"$$\\begin{matrix} E & \\rightarrow & E + T ; \\vert ; T \\ T & \\rightarrow & T * F ; \\vert ; F \\ F & \\rightarrow & \\lparen E \\rparen ; \\vert ; \\textbf{id} ;;; \\ \\end{matrix}$$",-1),O=t("p",null,"Eliminating the immediate left recursion (production of the form $A \\xRightarrow{+} A \\alpha$) to the production for E and then for T.",-1),D=t("div",{class:"custom-container tip"},[t("p",{class:"custom-container-title"},"Solution"),t("p",null,"$E \\rightarrow E + T ; \\vert ; T$ are replaced by"),t("p",null,"$$\\begin{matrix} E & \\rightarrow & TE' ;;;;;; \\ E' & \\rightarrow & +TE' ; \\vert ; \\epsilon \\ \\end{matrix}$$"),t("p",null,"$T \\rightarrow T * F ; \\vert ; F$ are replaced by"),t("p",null,"$$\\begin{matrix} T & \\rightarrow & FT' ;;;;;; \\ T' & \\rightarrow & *FT' ; \\vert ; \\epsilon \\ \\end{matrix}$$")],-1),J=t("h3",{id:"the-general-case",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#the-general-case","aria-hidden":"true"},"#"),e(" The general case")],-1),K=t("p",null,"Here, we shall deduce the general form for this formula. Immediate left recursion can be eliminated by the following technique, which works for any number of $A$-productions. First, group the productions as",-1),P=t("p",null,"$$A \\rightarrow A \\alpha_1 ; \\vert ; A \\alpha_2 ; \\vert ; \\cdots ; \\vert ; A \\alpha_m ; \\vert ; \\beta_1 ; \\vert ; \\beta_2 ; \\vert ; \\cdots ; \\vert ; \\beta_n$$",-1),Q=t("p",null,"where no $\\beta_i$ begins with an $A$. Then replace the $A$-productions by",-1),U=t("p",null,"$$\\begin{matrix} A & \\rightarrow & \\beta_1 A' ; \\vert ; \\beta_2 A' ; \\vert ; \\cdots ; \\vert ; \\beta_n A' ;;;;;; \\ A' & \\rightarrow & \\alpha_1 A' ; \\vert ; \\alpha_2 A' ; \\vert ; \\cdots ; \\vert ; \\alpha_m A' ; \\vert ; \\epsilon \\ \\end{matrix}$$",-1),X=t("p",null,"This eliminates all immediate left recursion, but it doesn't eliminate left recursion involving derivations of two ore more steps (not immediate). For example",-1),Y=t("p",null,"$$\\begin{matrix} S & \\rightarrow & Aa ; \\vert ; b ;;;;;;; \\ A & \\rightarrow & Ac ; \\vert ; Sd ; \\vert ; \\epsilon \\ \\end{matrix}$$ (2)",-1),Z=t("p",null,"The nonterminal $S$ is left recursive because $S \\Rightarrow Aa \\Rightarrow Sda$ but it is not immediately left recursive. Hence it can not be eliminate by the above technique. But still, in some cases we can try to handle it by the substitution. The second production in the grammar (2) becomes",-1),tt=t("p",null,"$$A \\rightarrow Ac ; \\vert ; Aad ; \\vert ; bd ; \\vert ; \\epsilon$$",-1),et=t("p",null,"Eliminating the immediate left recursion among these $A$-productions yields the following grammar.",-1),it=t("p",null,"$$\\begin{matrix} S & \\rightarrow & Aa ; \\vert ; b ;;;;;;;;;;; \\ A & \\rightarrow & bdA' ; \\vert ; A' ;;;;;; \\ A' & \\rightarrow & cA' ; \\vert ; adA' ; \\vert ; \\epsilon \\ \\end{matrix}$$",-1),at=t("h2",{id:"left-factoring",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#left-factoring","aria-hidden":"true"},"#"),e(" Left Factoring")],-1),rt=t("p",null,"Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive, or top-down, parsing. When the choice between two alternative $A$-productions is not clear, we may be able to rewrite the productions to defer the decision until enough of the input has been seen that we can make the right choice.",-1),nt=t("p",null,"For example, if we have the two productions",-1),ot=t("p",null,"(1) $$\\begin{matrix} \\textit{stmt} & \\rightarrow & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{stmt} ;;;;;;;;;;;;;;;; \\ & \\vert & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{stmt} ; \\textbf{else} ; \\textit{stmt} \\ & \\vert & \\textbf{other} ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ \\end{matrix}$$",-1),st=t("p",null,"on seeing the input token $\\textbf{if}$, we cannot immediately tell which production to choose to expand $\\textit{stmt}$. In general, suppose a grammar $A \\rightarrow \\alpha \\beta_1 ; \\vert ; \\alpha \\beta_2 ; \\vert ; \\cdots ; \\vert ; \\alpha \\beta_n ; \\vert ; \\gamma$ where $\\gamma$ represents all alternatives that do not begin with $\\alpha$, and the input begin with a nonempty string derived from $\\alpha$, we do not know which production to use.",-1),lt=t("p",null,"However, we may defer the decision by changing the grammar into",-1),ht=t("p",null,"$$\\begin{matrix} A & \\rightarrow & \\alpha A' ; \\vert ; \\gamma ;;;;;;;;;;;;;; \\ A' & \\rightarrow & \\beta_1 ; \\vert ; \\beta_2 ; \\vert ; \\cdots ; \\vert ; \\beta_n \\ \\end{matrix}$$",-1),ct=t("p",null,"Here $A'$ is a new nonterminal. Repeatedly apply this transformation until no two alternatives for a nonterminal have a common prefix.",-1),dt=t("h3",{id:"left-factoring-conditional-statement",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#left-factoring-conditional-statement","aria-hidden":"true"},"#"),e(" Left factoring conditional statement")],-1),mt=t("p",null,"The grammar (1) becomes",-1),ut=t("p",null,"$$\\begin{matrix} \\textit{stmt} & \\rightarrow & \\textbf{if} ; \\textit{expr} ; \\textbf{then} ; \\textit{stmt} ; \\textit{stmt'} ; \\vert ; \\textbf{other} \\ \\textit{stmt'} & \\rightarrow & \\textbf{else} ; \\textit{stmt} ; \\vert ; \\epsilon ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \\ \\end{matrix}$$",-1);function gt(ft,_t){const i=n("RouterLink");return l(),o(s,null,[u,g,t("nav",f,[t("ul",null,[t("li",null,[a(i,{to:"#lexical-versus-syntactic-analysis"},{default:r(()=>[_]),_:1})]),t("li",null,[a(i,{to:"#eliminating-ambiguity"},{default:r(()=>[p]),_:1})]),t("li",null,[a(i,{to:"#elimination-of-left-recursion"},{default:r(()=>[b]),_:1}),t("ul",null,[t("li",null,[a(i,{to:"#a-simple-left-recursion"},{default:r(()=>[x]),_:1})]),t("li",null,[a(i,{to:"#the-general-case"},{default:r(()=>[$]),_:1})])])]),t("li",null,[a(i,{to:"#left-factoring"},{default:r(()=>[w]),_:1}),t("ul",null,[t("li",null,[a(i,{to:"#left-factoring-conditional-statement"},{default:r(()=>[v]),_:1})])])])])]),A,y,T,E,F,k,S,L,R,q,H,V,W,B,I,C,G,N,j,z,M,O,D,J,K,P,Q,U,X,Y,Z,tt,et,it,at,rt,nt,ot,st,lt,ht,ct,dt,mt,ut],64)}var xt=h(m,[["render",gt]]);export{xt as default};
