import{_ as e,c as r,o as i,b as t}from"./app.b33521bb.js";const a="/course-notes/assets/figure-1.30886336.png",l="/course-notes/assets/figure-2.e790d0e1.png",s="/course-notes/assets/figure-3.c442e16c.png",o="/course-notes/assets/figure-4.8bb38c06.png",n="/course-notes/assets/figure-5.c41d9e43.png",c="/course-notes/assets/figure-6.e88ee9d2.png",k=JSON.parse('{"title":"Client-server Model","description":"","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[{"level":3,"title":"Client-server model","slug":"client-server-model-1","link":"#client-server-model-1","children":[]},{"level":3,"title":"Two types of open","slug":"two-types-of-open","link":"#two-types-of-open","children":[]},{"level":3,"title":"Iterative & concurrent clients","slug":"iterative-concurrent-clients","link":"#iterative-concurrent-clients","children":[]},{"level":3,"title":"Iterative & concurrent servers","slug":"iterative-concurrent-servers","link":"#iterative-concurrent-servers","children":[]}]},{"level":2,"title":"Categories of Servers","slug":"categories-of-servers","link":"#categories-of-servers","children":[{"level":3,"title":"File server","slug":"file-server","link":"#file-server","children":[]},{"level":3,"title":"Compute server","slug":"compute-server","link":"#compute-server","children":[]},{"level":3,"title":"Data server","slug":"data-server","link":"#data-server","children":[]},{"level":3,"title":"Database server","slug":"database-server","link":"#database-server","children":[]},{"level":3,"title":"Communication server","slug":"communication-server","link":"#communication-server","children":[]},{"level":3,"title":"Video server","slug":"video-server","link":"#video-server","children":[]}]},{"level":2,"title":"Client-server Architecture","slug":"client-server-architecture","link":"#client-server-architecture","children":[{"level":3,"title":"Three logic layers","slug":"three-logic-layers","link":"#three-logic-layers","children":[]},{"level":3,"title":"Client-server architectures","slug":"client-server-architectures","link":"#client-server-architectures","children":[]}]},{"level":2,"title":"Parallel Computer Architecture","slug":"parallel-computer-architecture","link":"#parallel-computer-architecture","children":[{"level":3,"title":"Application Partitioning","slug":"application-partitioning","link":"#application-partitioning","children":[]},{"level":3,"title":"Parallel Queries/Transaction","slug":"parallel-queries-transaction","link":"#parallel-queries-transaction","children":[]},{"level":3,"title":"Parallel computer architectures","slug":"parallel-computer-architectures","link":"#parallel-computer-architectures","children":[]}]},{"level":2,"title":"Middleware","slug":"middleware","link":"#middleware","children":[{"level":3,"title":"Types of middleware","slug":"types-of-middleware","link":"#types-of-middleware","children":[]}]}],"relativePath":"courses/cse491-network-application-programming/chapter-4.md"}'),d={name:"courses/cse491-network-application-programming/chapter-4.md"},h=t('<h1 id="client-server-model" tabindex="-1">Client-server Model <a class="header-anchor" href="#client-server-model" aria-hidden="true">#</a></h1><nav class="table-of-contents"><ul><li><a href="#introduction">Introduction</a><ul><li><a href="#client-server-model-1">Client-server model</a></li><li><a href="#two-types-of-open">Two types of open</a></li><li><a href="#iterative-concurrent-clients">Iterative &amp; concurrent clients</a></li><li><a href="#iterative-concurrent-servers">Iterative &amp; concurrent servers</a></li></ul></li><li><a href="#categories-of-servers">Categories of Servers</a><ul><li><a href="#file-server">File server</a></li><li><a href="#compute-server">Compute server</a></li><li><a href="#data-server">Data server</a></li><li><a href="#database-server">Database server</a></li><li><a href="#communication-server">Communication server</a></li><li><a href="#video-server">Video server</a></li></ul></li><li><a href="#client-server-architecture">Client-server Architecture</a><ul><li><a href="#three-logic-layers">Three logic layers</a></li><li><a href="#client-server-architectures">Client-server architectures</a></li></ul></li><li><a href="#parallel-computer-architecture">Parallel Computer Architecture</a><ul><li><a href="#application-partitioning">Application Partitioning</a></li><li><a href="#parallel-queries-transaction">Parallel Queries/Transaction</a></li><li><a href="#parallel-computer-architectures">Parallel computer architectures</a></li></ul></li><li><a href="#middleware">Middleware</a><ul><li><a href="#types-of-middleware">Types of middleware</a></li></ul></li></ul></nav><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-hidden="true">#</a></h2><ul><li>Client-server model <ul><li>Asymmetric relationship</li><li>Client predominately makes <strong>requests</strong>, while server makes <strong>replies</strong>.</li></ul></li><li>Peer-to-peer model <ul><li>Symmetric relationship</li><li>Each computer may request from or reply to <strong>any computer</strong></li></ul></li></ul><h3 id="client-server-model-1" tabindex="-1">Client-server model <a class="header-anchor" href="#client-server-model-1" aria-hidden="true">#</a></h3><p>Client program running on the local machine requests a service from another program running on the remote machine (i.e., server). Server provides service to any client, not a particular client.</p><ul><li>Client program may run only when <strong>it is needed</strong>.</li><li>Server program should run <strong>all the time</strong> (while loop), since it does not know when its service will be needed.</li></ul><h3 id="two-types-of-open" tabindex="-1">Two types of open <a class="header-anchor" href="#two-types-of-open" aria-hidden="true">#</a></h3><ol><li>Active open: (client) <ul><li>Client opens the communication channel using IP address of the remote host and port address of the server program.</li><li>Request-response may be repeated several times, and the client process runs for only a while.</li><li>Client close the communication channel with an active close.</li></ul></li><li>Passive open: (server) <ul><li>Server program opens its door for incoming requests from clients but never initiates a service unless explicitly requested.</li><li>Server program runs forever unless a problem occurs.</li></ul></li></ol><h3 id="iterative-concurrent-clients" tabindex="-1">Iterative &amp; concurrent clients <a class="header-anchor" href="#iterative-concurrent-clients" aria-hidden="true">#</a></h3><ul><li>Iterative client: <ul><li>One client program must start, run, and <strong>terminate</strong> before another client program starts</li></ul></li><li>Concurrent client: <ul><li>Two or more client programs can run at the same time (concurrently) on a machine using <strong>time-sharing</strong> mechanism. For example, browsing the web while on an Internet call with your friend.</li></ul></li></ul><h3 id="iterative-concurrent-servers" tabindex="-1">Iterative &amp; concurrent servers <a class="header-anchor" href="#iterative-concurrent-servers" aria-hidden="true">#</a></h3><ul><li>Iterative server: <ul><li>Iterative server can process only one request at a time.</li><li>Connectionless iterative server: servers using <strong>UDP</strong> are usually iterative (using one single port; arriving packets will wait in line).</li></ul></li><li>Concurrent server: <ul><li>Concurrent server can process many requests at the same time (time sharing)</li><li>Connection-oriented concurrent server: Servers using <strong>TCP</strong> are usually concurrent (using multiple ports; arriving packets may be handled by multiple processes or threads).</li></ul></li></ul><h2 id="categories-of-servers" tabindex="-1">Categories of Servers <a class="header-anchor" href="#categories-of-servers" aria-hidden="true">#</a></h2><p>Servers are usually identified by their functions. Most common servers include:</p><ol><li><a href="#file-server">File server</a></li><li><a href="#compute-server">Compute server</a></li><li><a href="#data-server">Data server</a></li><li><a href="#database-server">Database server</a></li><li><a href="#communication-server">Communication server</a></li><li><a href="#video-server">Video server</a></li></ol><h3 id="file-server" tabindex="-1">File server <a class="header-anchor" href="#file-server" aria-hidden="true">#</a></h3><ul><li>File server manages <strong>application and data files</strong> of a working group, so these files can be shared by that group. <ul><li>E.g. Office NAS</li></ul></li><li>Usually, file servers are very <strong>I/O-oriented</strong>. <ul><li>File server pulls a large amount of data off the storage subsystem and passes these data over network.</li><li>This requires large-bandwidth network connections and a large-capacity, fast hard-disk subsystem.</li></ul></li></ul><h3 id="compute-server" tabindex="-1">Compute server <a class="header-anchor" href="#compute-server" aria-hidden="true">#</a></h3><p>Compute servers perform application and logic processing. Compute server requires</p><ol><li>Processors (GPU) with high performance capabilities</li><li>Large amounts of memory</li><li>Relatively low disk subsystems (I/O are super slow)</li></ol><p>By separating data from the computation processing, compute server\u2019s processing capability can be optimized. And it get data from the <strong>data server</strong>.</p><h3 id="data-server" tabindex="-1">Data server <a class="header-anchor" href="#data-server" aria-hidden="true">#</a></h3><p>Data servers are mainly used for data storage and <strong>management</strong>. Since a data server can serve more than one compute server, compute-intensive applications can be spread among multiple severs (watch out for the <strong>data race</strong>).</p><ul><li>However, data servers do not prefer any application and logic processing.</li><li>Data server performs processes such as <strong>data validation</strong> (different from file servers), required as part of data management function.</li><li>Data server requires fast processors, large amount of memory, and substantial hard disk capacity.</li></ul><div class="tip custom-block"><p class="custom-block-title">Example of Data Server</p><p>A system composed of both <strong>web server</strong> and <strong>data server</strong>. This design prevent the direct access of the data server from users, providing</p><ul><li>Security: add firewall between web and data server</li><li>Performance: only get data when needed</li></ul><p><img src="'+a+'" alt="figure-1"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote></div><h3 id="database-server" tabindex="-1">Database server <a class="header-anchor" href="#database-server" aria-hidden="true">#</a></h3><p>Database servers are the most typical use of technology in a client-server model. These servers accept data requests (queries), retrieve data from their database (or further request data from another server), and then pass results back to the client.</p><ul><li>Database server = Compute server + Data server</li><li>Database servers store the dedicated <strong>database</strong></li><li>They handle the query language (mysql, etc.) from the user and query the corersponding data from the database</li><li>Server requirement depends on <ul><li>Size of database</li><li>Speed that database must be updated</li><li>The number of users</li><li>The type of network used</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">Example of Database Server</p><ul><li>Distributed processing application connects to remote database</li><li>It can also have a local caching database (just like proxy, DNS)</li></ul><p><img src="'+l+'" alt="figure-2"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote></div><h3 id="communication-server" tabindex="-1">Communication server <a class="header-anchor" href="#communication-server" aria-hidden="true">#</a></h3><p>Communication server acts as a gateway to connect with other LANs, networks, or computers.</p><ul><li>E.g. Email server and Internet server</li><li>It requires modest system resource: <ul><li>Multiple network slots</li><li>Fast processor to translate networking protocols</li></ul></li></ul><h3 id="video-server" tabindex="-1">Video server <a class="header-anchor" href="#video-server" aria-hidden="true">#</a></h3><p>Video servers can be used in a number of contexts, some of which include:</p><ol><li>News</li><li>Production</li><li>Instruction</li><li>Public access</li><li>Surveillance</li><li>Entertainment</li></ol><h2 id="client-server-architecture" tabindex="-1">Client-server Architecture <a class="header-anchor" href="#client-server-architecture" aria-hidden="true">#</a></h2><h3 id="three-logic-layers" tabindex="-1">Three logic layers <a class="header-anchor" href="#three-logic-layers" aria-hidden="true">#</a></h3><table><thead><tr><th>Client-side software</th><th>Server-side software</th></tr></thead><tbody><tr><td>Service logic</td><td>Service logic</td></tr><tr><td>Application logic</td><td>Application logic</td></tr><tr><td>Presentation logic</td><td></td></tr></tbody></table><p>The server-side software typically don&#39;t have the <strong>presentation logic</strong> since is do not require a complex UI.</p><h4 id="service-logic" tabindex="-1">Service logic <a class="header-anchor" href="#service-logic" aria-hidden="true">#</a></h4><p>Provide inter-process communication (IPC) service, which is what we&#39;ve mostly learn so far.</p><h4 id="application-logic" tabindex="-1">Application logic <a class="header-anchor" href="#application-logic" aria-hidden="true">#</a></h4><ol><li>Processing component logic: <ul><li>Business rules logic</li><li>Data management logic</li><li>Identifies the data necessary for processing transaction or query</li><li>E.g. <strong>compute</strong> the mean score of the class</li></ul></li><li>Storage component logic: <ul><li>Deal with data storage and retrieval from physical storage devices.</li><li>Database management system (DBMS) activities occur here.</li><li>E.g. <strong>filter</strong> the score larger than 60 (no computation).</li></ul></li></ol><h4 id="presentation-logic" tabindex="-1">Presentation logic <a class="header-anchor" href="#presentation-logic" aria-hidden="true">#</a></h4><p>Format and present data on user\u2019s output device (e.g., screen) and manage user input from user\u2019s input device (e.g., keyboard).</p><h3 id="client-server-architectures" tabindex="-1">Client-server architectures <a class="header-anchor" href="#client-server-architectures" aria-hidden="true">#</a></h3><p>There are three types of client-server architectures, <strong>from fat client to thin client</strong></p><ol><li>File server architecture</li><li>Database server architecture</li><li>Three-tier architecture</li></ol><div class="tip custom-block"><p class="custom-block-title">Example</p><p>Before dive into the each architecture, let&#39;s see a example first.</p><p><strong>Task</strong>: Get the mean score of the class</p><p><strong>File server</strong></p><ol><li>Transmit the entire DBMS to the client</li><li>Filter out the socres info on the client</li><li>Compute the mean on the client</li></ol><p><strong>Database server</strong></p><ol><li>Queries the database for scores only</li><li>Transmit the socres to the client</li><li>Compute the mean on the client</li></ol><p><strong>Three-tier</strong></p><ol><li>Queries the database for scores only</li><li>Compute the mean on the server</li><li>Transmit the mean score to the client</li></ol></div><h4 id="file-server-architecture" tabindex="-1">File server architecture <a class="header-anchor" href="#file-server-architecture" aria-hidden="true">#</a></h4><p>Clients handles</p><ol><li>Processing logic</li><li>Storage logic</li><li>Presentation logic</li></ol><p>Each clients is called a <strong>fat</strong> client since most processing occurs on the client side. While the file servers is a device that manages file operations and is shared by each of client PCs attached to LAN.</p><ul><li>Each file server acts as an additional hard disk for each client.</li><li><strong>Entire files</strong> are transferred from server to client for processing.</li></ul><h5 id="problems" tabindex="-1">Problems <a class="header-anchor" href="#problems" aria-hidden="true">#</a></h5><ol><li>Huge amount of data has to be transferred on network. <ul><li>The whole files are transfered. Server is doing very little work.</li><li>Network is congested</li><li>The client is busy with extensive data manipulation.</li></ul></li><li>Each client is authorized to use DBMS when a database application program runs on that PC. <ul><li>There is one database but many concurrently running copies of DBMS (one on each PC), so heavy resource demand on clients.</li></ul></li><li>DBMS copy in each client PC must manage the shared <strong>database integrity</strong><ul><li>Shared locks and integrity checks</li><li>Multi-user database environment <ul><li>Concurrency control</li><li>Recovery control</li><li>Security control</li></ul></li></ul></li></ol><h4 id="database-server-architecture" tabindex="-1">Database server architecture <a class="header-anchor" href="#database-server-architecture" aria-hidden="true">#</a></h4><ul><li>A <strong>two-tiered</strong> approach. Client is responsible for <ol><li>User interface</li><li>I/O processing logic</li><li>Data processing logic</li><li>Some business rules logic (front-end program)</li></ol></li><li><strong>Database server</strong> performs all <strong>data storage</strong> and <strong>access processing</strong> (back-end functions).</li><li>DBMS is only on the server</li></ul><p>Thus, clients need not be powerful. Only database server requires processing power to handle the database.</p><ul><li>Server can be tuned to optimize data processing performance</li><li>Reduces data traffic on network, since only records (rather than whole tables) that match the requested criteria are transmitted.</li><li>This also improves data integrity since it is all processed centrally.</li></ul><h5 id="advantages" tabindex="-1">Advantages <a class="header-anchor" href="#advantages" aria-hidden="true">#</a></h5><p>The unified API is provided by the back-end program which handles the application logic</p><ul><li>Enhance performance for compiled <strong>SQL statements</strong></li><li>Reduce network traffic and improve security since only the records are transmitted</li><li>Improve data integrity since the unified API</li><li>Thinner clients</li></ul><h5 id="disadvantages" tabindex="-1">Disadvantages <a class="header-anchor" href="#disadvantages" aria-hidden="true">#</a></h5><ul><li>Proprietary nature reduces portability</li><li>Performance degrades when the number of online users increases.</li></ul><h4 id="three-tier-architecture" tabindex="-1">Three-tier architecture <a class="header-anchor" href="#three-tier-architecture" aria-hidden="true">#</a></h4><p>3-tier architecture provides a dedicated application server to handle application logic and a database server to handle data processing logic.</p><ul><li>Client <ul><li>Presentation logic (pure front-end)</li><li>I/O processing logic</li></ul></li><li>Application Server <ul><li>Application logic (pure backend)</li><li>Business rules</li><li>API</li></ul></li><li>Database Server <ul><li>Data processing logic</li><li>DBMS</li></ul></li></ul><h5 id="advantages-1" tabindex="-1">Advantages <a class="header-anchor" href="#advantages-1" aria-hidden="true">#</a></h5><ol><li>Scalability <ul><li>Middle tier reduces the load on database sever by using a transaction processing monitor to reduce connections to a server.</li><li>More application servers can be added to distribute application load.</li></ul></li><li>Technological flexibility <ul><li>Middle tier can be moved to a different platform (i.e., easier to change DBMS engines).</li><li>Simplified presentation makes it easier to implement new GUI, even on multi-platform (desktop, mobile)</li></ul></li><li>Improved customer service <ul><li>Multiple interfaces (desktop, mobile) on different clients can access the same business process.</li></ul></li><li>Long-term cost reduction <ul><li>With seperated, interchangeable modules, it&#39;s easier to maintain or upgrade a specific part instead of the entire system.</li></ul></li><li>Better match of systems to business needs <ul><li>Can be substitued with the domain-specific modules</li></ul></li><li>Competitive advantage <ul><li>Quick react to <strong>business change</strong> by changing small modules</li></ul></li></ol><h5 id="challenges" tabindex="-1">Challenges <a class="header-anchor" href="#challenges" aria-hidden="true">#</a></h5><ol><li>High short-term costs <ul><li>More costs on a tiny project</li></ul></li><li>Lack of Tools, training, and experience</li><li>Incompatible standards</li><li>Lack of compatible end-user tools</li></ol><h2 id="parallel-computer-architecture" tabindex="-1">Parallel Computer Architecture <a class="header-anchor" href="#parallel-computer-architecture" aria-hidden="true">#</a></h2><h3 id="application-partitioning" tabindex="-1">Application Partitioning <a class="header-anchor" href="#application-partitioning" aria-hidden="true">#</a></h3><p>Placing portions of application code in different locations (client vs. server) after it is written, has several advantages</p><ol><li>Improve performance</li><li>Enhance interoperability</li><li>Balance workloads across the tiers</li><li>Object-oriented development is suitable for this concept</li><li>Necessary in web environment, in order to achieve desired performance in an unpredictable distributed environment</li></ol><p>Moreover, the ability to handle high transaction volumes, complex queries, and new data types has shown to be problematic in a uniprocessor environment.</p><h3 id="parallel-queries-transaction" tabindex="-1">Parallel Queries/Transaction <a class="header-anchor" href="#parallel-queries-transaction" aria-hidden="true">#</a></h3><p>Relational DBMS (RDBMS) and SQL lend themselves to a parallel environment in two ways:</p><ol><li>Parallel queries</li><li>Parallel transactions</li></ol><h4 id="parallel-queries" tabindex="-1">Parallel queries <a class="header-anchor" href="#parallel-queries" aria-hidden="true">#</a></h4><p>If multiple queries can be run in parallel on different processors, they are called parallel queries.</p><p><img src="'+s+'" alt="figure-3"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h4 id="parallel-transactions" tabindex="-1">Parallel transactions <a class="header-anchor" href="#parallel-transactions" aria-hidden="true">#</a></h4><p>SQL acts as a non-procedural set processing language in most queries. Queries can be divided into parts, each of which can be run on a different processor simultaneously. This is called parallel transactions.</p><p><img src="'+o+'" alt="figure-4"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h3 id="parallel-computer-architectures" tabindex="-1">Parallel computer architectures <a class="header-anchor" href="#parallel-computer-architectures" aria-hidden="true">#</a></h3><ul><li>SMP (tightly-coupled) <ul><li>CPUs share the <strong>common</strong> memory space</li><li>More expansive</li></ul></li><li>MPP (loosely-coupled) <ul><li>Each CPU has its <strong>own</strong> memmory space</li><li>More common</li></ul></li></ul><h4 id="smp" tabindex="-1">SMP <a class="header-anchor" href="#smp" aria-hidden="true">#</a></h4><p>In symmetric multi-processing (SMP) architecture, tightly coupled processors have the common shared memory.</p><ul><li>Single copy of the operating system resides in the shared memory.</li><li>Bottlenecks are lessened compared to uniprocessor systems, because all processors share all tasks.</li><li>For situations where data must remain in memory during processing to achieve the desired performance/ <ul><li>But this may lead to potential problems of contention (data race) for the shared memory.</li></ul></li></ul><h4 id="mpp" tabindex="-1">MPP <a class="header-anchor" href="#mpp" aria-hidden="true">#</a></h4><p>In massively parallel processing (MPP) architecture, each loosely coupled process has its own memory. It requires a copy of the operating system to be resident in each dedicated memory.</p><ul><li>Easier to add processors incrementally since there is (almost) no memory contention problem.</li><li>Applications that have large tasks can easily be divided up and worked on simultaneously.</li></ul><h2 id="middleware" tabindex="-1">Middleware <a class="header-anchor" href="#middleware" aria-hidden="true">#</a></h2><p>Generally speaking, middleware is the glue that holds client and server applications together. Middleware is a software that allows an application to interoperate with other software, without asking users to code low-level operations (e.g. socket use pure string) used to achieve interoperability.</p><ul><li>With synchronous systems, the requesting system waits for a response to the request in real time.</li><li>Asynchronous systems send a request but do not wait for a response in real time. The response is accepted when it is received.</li></ul><h3 id="types-of-middleware" tabindex="-1">Types of middleware <a class="header-anchor" href="#types-of-middleware" aria-hidden="true">#</a></h3><p><img src="'+n+'" alt="figure-5"></p><ol><li>Asynchronous remote procedure call (RPC) <ul><li>Client makes calls to procedures running on remote computers, but does not wait for a response.</li><li>If connection is lost, the client must reestablish connection and send request again.</li><li>It is high scalability but low recovery, so this middleware is largely replaced by synchronous RPC.</li></ul></li><li>Synchronous RPC <ul><li>Distributed program using this middleware may call services available on different computers.</li><li>It is possible to achieve this without undertaking detailed coding.</li><li>E.g. Java remote method invocation (RMI)</li></ul></li><li>Publish/subscribe (also called push technology) <ul><li>Server monitors activity and sends information to client when available.</li><li>It is asynchronous, so clients (i.e., subscribers) perform other activities between notifications from server.</li><li>It is useful for monitoring situations where actions need to be taken when particular events occur.</li></ul></li><li>Message-oriented middleware (MOM) <ul><li>MOM sends messages that are collected and stored until they are acted upon, while the client continues with other processing (in other words, MOM is asynchronous).</li></ul></li><li>Object request broker (ORB) <ul><li>ORB provides object-oriented management of communications between clients and servers.</li><li>It tracks location of each object and routes requests to each object.</li></ul></li><li>SQL-oriented data access <ul><li>This is a middleware between applications and database servers.</li><li>It has the capability to translate generic SQL into SQL specific to database.</li></ul></li><li>Database middleware: ODBC <ul><li>ODBC is an application program interface (API) to provide a common language for user programs to access SQL databases independent of the particular RDBMS that is accessed.</li></ul></li></ol><p><img src="'+c+'" alt="figure-6"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote>',105),u=[h];function p(m,g,v,f,b,y){return i(),r("div",null,u)}const P=e(d,[["render",p]]);export{k as __pageData,P as default};
