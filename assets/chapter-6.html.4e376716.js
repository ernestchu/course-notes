import{e}from"./app.bdc3a143.js";import{_ as t}from"./plugin-vue_export-helper.5a098b48.js";const r={},n=e('<h1 id="design-of-server-software" tabindex="-1"><a class="header-anchor" href="#design-of-server-software" aria-hidden="true">#</a> Design of Server Software</h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p>Conceptually, a as server follows a simple algorithm</p><ol><li>Create and bind a socket to a well-known port</li><li>Enter an infinite loop <ul><li>Accept the next request from a client</li><li>Process the request and reply the result to client</li></ul></li></ol><p>Types of servers</p><table><thead><tr><th></th><th>Iterative</th><th>Concurrent</th></tr></thead><tbody><tr><td>Connectionless</td><td>Iterative connectionless servers</td><td>Iterative connection-oriented servers</td></tr><tr><td>Connection-oriented</td><td>Concurrent connectionless servers <strong>(rarely used)</strong></td><td>Concurrent connection-oriented servers</td></tr></tbody></table><h2 id="iterative-servers" tabindex="-1"><a class="header-anchor" href="#iterative-servers" aria-hidden="true">#</a> Iterative Servers</h2><h3 id="connectionless-server" tabindex="-1"><a class="header-anchor" href="#connectionless-server" aria-hidden="true">#</a> Connectionless server</h3><ol><li>Create and bind a socket to a well-known port</li><li>Enter an infinite loop <ul><li>Accept the next request from a client</li><li>Process the request and reply the result to client</li></ul></li></ol><p>The server only procides one single socket. Server can use <code>sendto()</code> and <code>recvfrom()</code> to get the address information of clients.</p><h3 id="connection-oriented" tabindex="-1"><a class="header-anchor" href="#connection-oriented" aria-hidden="true">#</a> Connection-oriented</h3><ol><li>Create and bind a socket to a well-known port</li><li>Place the socket in passive mode by calling <code>listen()</code></li><li>Accept the next connection and obtain a new socket for the connection</li><li>Enter an infinite loop <ul><li>Accept the next request from a client</li><li>Process the request and reply the result to client</li></ul></li><li>When finishing with a client, close the connection and reutrn to step 3 to accept a new connection</li></ol><h2 id="concurrent-servers" tabindex="-1"><a class="header-anchor" href="#concurrent-servers" aria-hidden="true">#</a> Concurrent Servers</h2><p>Concurrency reduces response time for multiple clients under serveral conditions</p><ul><li>Siginificant I/O exists</li><li>Processing time varies dramatically among requests <ul><li>Small processes don&#39;t have to wait for big processes to finish</li></ul></li><li>Computer with multiple processors</li></ul><p>Most concurrent server use multiple processes (or threads) tp achieve concurrency</p><ul><li>A single process (called mastser) begins execution initially</li><li>The master process then <ol><li>Open a socekt at the well-know port</li><li>Wait for the next request</li><li>Create a slave to handle each request</li></ol></li><li>Each slave process handles communication with one client. Once the client disconnectm the slave process exits</li></ul><h3 id="connectionless-server-1" tabindex="-1"><a class="header-anchor" href="#connectionless-server-1" aria-hidden="true">#</a> Connectionless server</h3><p><strong>Master algorithm</strong></p><ol><li>Create and bind the socket to a well-known port</li><li>Reapeatedly call <code>recvfrom()</code> to receive the next request from a client and create a new slave processs (or thread) to handle that response</li></ol><p><strong>Slave algorithm</strong></p><ol><li>Access to the corresponding socket</li><li>Form a reply and send it to the client using <code>sendto()</code></li><li>Exit when finish</li></ol><div class="custom-container warning"><p class="custom-container-title">Cost of Concurrency</p><p>The cost of concurrency could be greater than the gain in speed in connectionless server. So very few connectionless server enforce a concurrent algorithm</p></div><h3 id="connection-oriented-server" tabindex="-1"><a class="header-anchor" href="#connection-oriented-server" aria-hidden="true">#</a> Connection-oriented server</h3><p><strong>Master algorithm</strong></p><ol><li>Create and bind a socket to a well-known port</li><li>Place the socket in passive mode</li><li>Repeatedly call <code>accept()</code> to receive the next request and create a new slave process to handle the response</li></ol><p><strong>Slave algorithm</strong></p><ol><li>Begin with a connection passed from the master</li><li>Interact with client</li><li>Close the connection and exit</li></ol><h2 id="advanced-issues" tabindex="-1"><a class="header-anchor" href="#advanced-issues" aria-hidden="true">#</a> Advanced Issues</h2><h3 id="create-a-new-process" tabindex="-1"><a class="header-anchor" href="#create-a-new-process" aria-hidden="true">#</a> Create a new process</h3><h3 id="use-only-one-thread-to-achieve-concurrency" tabindex="-1"><a class="header-anchor" href="#use-only-one-thread-to-achieve-concurrency" aria-hidden="true">#</a> Use only one thread to achieve concurrency</h3><h3 id="guidelines-to-select-different-types-of-servers" tabindex="-1"><a class="header-anchor" href="#guidelines-to-select-different-types-of-servers" aria-hidden="true">#</a> Guidelines to select different types of servers</h3><h3 id="deadlock" tabindex="-1"><a class="header-anchor" href="#deadlock" aria-hidden="true">#</a> Deadlock</h3><h2 id="example-of-iterative-servers" tabindex="-1"><a class="header-anchor" href="#example-of-iterative-servers" aria-hidden="true">#</a> Example of Iterative Servers</h2>',34);function i(o,a){return n}var l=t(r,[["render",i]]);export{l as default};
