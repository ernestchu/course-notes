import{_ as e,c as t,o as s,b as o}from"./app.b33521bb.js";const n="/course-notes/assets/pytorch.f3c6afb5.png",a="/course-notes/assets/figure-1.76bb253c.png",r="/course-notes/assets/figure-2.518a75ff.png",i="/course-notes/assets/figure-3.f73ea989.png",l="/course-notes/assets/figure-4.2d22294e.png",c="/course-notes/assets/figure-5.6bfd9d12.png",d="/course-notes/assets/figure-6.8ce9085f.png",p="/course-notes/assets/figure-7.d00f0a9d.png",h="/course-notes/assets/figure-8.11ee913b.png",u="/course-notes/assets/figure-9.6a9d1c3e.png",g="/course-notes/assets/figure-10.feed0f18.png",m="/course-notes/assets/figure-11.184c90f7.png",f="/course-notes/assets/figure-12.b0236ae7.png",b="/course-notes/assets/figure-13.6ba9a282.png",y="/course-notes/assets/figure-14.adcc4b07.png",w="/course-notes/assets/figure-15.6808f0b8.png",C="/course-notes/assets/figure-16.d7aeffa6.png",k="/course-notes/assets/figure-17.d3bf4d2d.png",v="/course-notes/assets/figure-18.00bab167.png",D="/course-notes/assets/figure-19.8d576e0e.png",A="/course-notes/assets/figure-20.a3b8bc11.png",F="/course-notes/assets/figure-21.bd8d9fae.png",P="/course-notes/assets/figure-22.1e1fa9f3.png",q="/course-notes/assets/figure-23.d145cf60.png",T="/course-notes/assets/figure-24.86f2acd2.png",Y=JSON.parse('{"title":"Transport Layer Protocols","description":"","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[{"level":3,"title":"Jobs of tranport layer","slug":"jobs-of-tranport-layer","link":"#jobs-of-tranport-layer","children":[]},{"level":3,"title":"Internet socket","slug":"internet-socket","link":"#internet-socket","children":[]},{"level":3,"title":"Communications","slug":"communications","link":"#communications","children":[]},{"level":3,"title":"Functions in transport layer","slug":"functions-in-transport-layer","link":"#functions-in-transport-layer","children":[]},{"level":3,"title":"BSD socket interface","slug":"bsd-socket-interface","link":"#bsd-socket-interface","children":[]}]},{"level":2,"title":"Unreliable Protocol: UDP","slug":"unreliable-protocol-udp","link":"#unreliable-protocol-udp","children":[{"level":3,"title":"UDP header format","slug":"udp-header-format","link":"#udp-header-format","children":[]}]},{"level":2,"title":"Reliable Protocol: TCP","slug":"reliable-protocol-tcp","link":"#reliable-protocol-tcp","children":[{"level":3,"title":"Connection management","slug":"connection-management","link":"#connection-management","children":[]},{"level":3,"title":"Reliability of data transfers","slug":"reliability-of-data-transfers","link":"#reliability-of-data-transfers","children":[]},{"level":3,"title":"Flow control","slug":"flow-control","link":"#flow-control","children":[]},{"level":3,"title":"Congetsion control","slug":"congetsion-control","link":"#congetsion-control","children":[]},{"level":3,"title":"Header format and timer management","slug":"header-format-and-timer-management","link":"#header-format-and-timer-management","children":[]}]}],"relativePath":"courses/cse491-network-application-programming/chapter-2.md"}'),_={name:"courses/cse491-network-application-programming/chapter-2.md"},I=o('<h1 id="transport-layer-protocols" tabindex="-1">Transport Layer Protocols <a class="header-anchor" href="#transport-layer-protocols" aria-hidden="true">#</a></h1><nav class="table-of-contents"><ul><li><a href="#introduction">Introduction</a><ul><li><a href="#jobs-of-tranport-layer">Jobs of tranport layer</a></li><li><a href="#internet-socket">Internet socket</a></li><li><a href="#communications">Communications</a></li><li><a href="#functions-in-transport-layer">Functions in transport layer</a></li><li><a href="#bsd-socket-interface">BSD socket interface</a></li></ul></li><li><a href="#unreliable-protocol-udp">Unreliable Protocol: UDP</a><ul><li><a href="#udp-header-format">UDP header format</a></li></ul></li><li><a href="#reliable-protocol-tcp">Reliable Protocol: TCP</a><ul><li><a href="#connection-management">Connection management</a></li><li><a href="#reliability-of-data-transfers">Reliability of data transfers</a></li><li><a href="#flow-control">Flow control</a></li><li><a href="#congetsion-control">Congetsion control</a></li><li><a href="#header-format-and-timer-management">Header format and timer management</a></li></ul></li></ul></nav><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-hidden="true">#</a></h2><h3 id="jobs-of-tranport-layer" tabindex="-1">Jobs of tranport layer <a class="header-anchor" href="#jobs-of-tranport-layer" aria-hidden="true">#</a></h3><ul><li>Addressing <ul><li>Determine which application process a packet belongs to (through <strong>ports</strong>).</li></ul></li><li>Error control <ul><li>Detect if the received data is valid</li></ul></li><li>Reliability <ul><li>Ensure that the transferred data will reach its destination</li></ul></li><li>Rate control <ul><li>Adjust how fast the sender should transfer the data to the receiver (avoid packet dropping)</li></ul></li><li>UDP vs. TCP <ul><li>Both <strong>user datagram protocol (UDP)</strong> and <strong>transmission control protocol (TCP)</strong> are two well-known protocols in the transport layer. But TCP is more <strong>sophisticated</strong> and <strong>complicated</strong> than UDP</li></ul></li></ul><table><thead><tr><th>Protocol</th><th>Addressing</th><th>Error control</th><th>Reliability</th><th>Rate control</th></tr></thead><tbody><tr><td>UDP</td><td>\u2714\uFE0F</td><td>Optional</td><td>\u274C</td><td>\u274C</td></tr><tr><td>TCP</td><td>\u2714\uFE0F</td><td>\u2714\uFE0F</td><td>\u2714\uFE0F</td><td>\u2714\uFE0F</td></tr></tbody></table><p>However, TCP is more difficult to implement since it needs to</p><ul><li>Establish an <strong>end-to-end logical connection</strong> between the sender and receiver</li><li>Keep necessary <strong>per-connection</strong> state information</li></ul><h3 id="internet-socket" tabindex="-1">Internet socket <a class="header-anchor" href="#internet-socket" aria-hidden="true">#</a></h3><p>When deveoping network applications, hopefully, you don&#39;t have to bother with how packets are transmitted. The Internet <strong>socket</strong> serves as an <strong>API</strong> for programmers to access the <em>underlying services of IP suite</em>. You&#39;ve probably heard the term API. Think about training a neural network model. If everybody has to write their own backpropagation function to compute gradients, Deep Learning woudln&#39;t have been so popular. Instead, we use ML frameworks such as Pytoch and every function provided by Pytoch is just like an <strong>interface</strong> which let us build Convolution layer without knowing how it&#39;s implemented in the backend.</p><p>A good <strong>documentation</strong> explaining the API is a fundamental requirement for any well-known frameworks, otherwise users like us would have no idea how to use these APIs.</p><p><img src="'+n+'" alt="pytorch"></p><p>However, applications can sometimes bypass transport layer and directly use the services provided by, for example</p><ul><li>Network layer: routing table</li><li>Data link layers: LAN card driver</li></ul><h3 id="communications" tabindex="-1">Communications <a class="header-anchor" href="#communications" aria-hidden="true">#</a></h3><table><thead><tr><th></th><th>Host-to-host</th><th>Process-to-process</th></tr></thead><tbody><tr><td><strong>Latency</strong></td><td>short</td><td>long</td></tr><tr><td><strong>Jitter</strong></td><td>small</td><td>large</td></tr><tr><td><strong>Flow control</strong></td><td>easy</td><td>need extra protocols</td></tr></tbody></table><blockquote><p>Jitter: you can think it as <em>variance</em></p><table><thead><tr><th>small</th><th>large</th></tr></thead><tbody><tr><td>0.1s</td><td>0.01s</td></tr><tr><td>0.2s</td><td>0.3s</td></tr><tr><td>0.1s</td><td>20s</td></tr><tr><td>0.1s</td><td>0.01s</td></tr></tbody></table></blockquote><p>While host-to-host communication in IP or data link layers has low latency and small jitter, the process-to-process communication has relatively opposite. Therefore, you need extra protocols (or layer) to control the flow rate in a multi-hop networ, that is <strong>Transport layer</strong>.</p><p><img src="'+a+`" alt="figure-1"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h3 id="functions-in-transport-layer" tabindex="-1">Functions in transport layer <a class="header-anchor" href="#functions-in-transport-layer" aria-hidden="true">#</a></h3><ol><li>Addressing</li><li>Error control &amp; reliability</li><li>Rate control</li><li>Socket programming interface</li></ol><h4 id="addressing" tabindex="-1">Addressing <a class="header-anchor" href="#addressing" aria-hidden="true">#</a></h4><p>There are many process runnning on a host, so transport lyer defines the <strong>port number</strong> (16 bits in the Internet solution) to multiplex and demultiplex. When pacekts arrive on your computer based on the IP address, they need to knowhich process do they go next, i.e., demultiplexing. And vice versa when packets go out from each process.</p><p>Port number can be either <strong>well-known</strong> (e.g. SSH uses port 22) or <em>dynamically assigned</em>.</p><h4 id="error-control-reliability" tabindex="-1">Error control &amp; reliability <a class="header-anchor" href="#error-control-reliability" aria-hidden="true">#</a></h4><p>Transport layer usually adopts cyclic redundancy check (<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noreferrer">CRC</a>) and <strong>checksum</strong> for error detection to guarantee data integrity. Here we give a simple example of the checksum calculation. Suppose that we have the following three 16-bit words.</p><div class="language-"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">0110011001100000</span></span>
<span class="line"><span style="color:#A6ACCD;">0101010101010101</span></span>
<span class="line"><span style="color:#A6ACCD;">1000111100001100</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>The sum of first two of these 16-bit words is</p><div class="language-"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">0110011001100000</span></span>
<span class="line"><span style="color:#A6ACCD;">0101010101010101</span></span>
<span class="line"><span style="color:#A6ACCD;">---------------- addition</span></span>
<span class="line"><span style="color:#A6ACCD;">1011101110110101</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Adding the third word to the above sum gives</p><div class="language-"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">1011101110110101</span></span>
<span class="line"><span style="color:#A6ACCD;">1000111100001100</span></span>
<span class="line"><span style="color:#A6ACCD;">---------------- addition</span></span>
<span class="line"><span style="color:#A6ACCD;">0100101011000010</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Note that the second addition had overflow, which the leading 1 was wrapped around and add to the trailing bit.</p><p>Finally, perform 1&#39;s complement then we get the checksum</p><div class="language-"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">0100101011000010</span></span>
<span class="line"><span style="color:#A6ACCD;">---------------- 1&#39;s complement</span></span>
<span class="line"><span style="color:#A6ACCD;">1011010100111101</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="rate-control" tabindex="-1">Rate control <a class="header-anchor" href="#rate-control" aria-hidden="true">#</a></h4><ul><li><strong>Window-based</strong> control regulates the sending rate by controlling the number of <em>outstanding</em> packets (i.e. a packet that has been sent but its <strong>ACK</strong> has not returned yet) which can be <em>simultaneously</em> in transit.</li><li><strong>Rate-based</strong> control allows the sender to directly adjust its sending rate when receiving an explicit notification of how fast it should send.</li></ul><h4 id="socket-programming-interface" tabindex="-1">Socket programming interface <a class="header-anchor" href="#socket-programming-interface" aria-hidden="true">#</a></h4><ul><li>TCP socket vs. UDP socket <ul><li>We&#39;ll discuss in details later</li></ul></li><li>BSD socket interface semantic <ul><li>Explained below</li></ul></li></ul><h3 id="bsd-socket-interface" tabindex="-1">BSD socket interface <a class="header-anchor" href="#bsd-socket-interface" aria-hidden="true">#</a></h3><h4 id="procedures-for-outgoing-packets" tabindex="-1">Procedures for outgoing packets <a class="header-anchor" href="#procedures-for-outgoing-packets" aria-hidden="true">#</a></h4><ol><li>An app can choose either <code>sendto()</code> (UDP, RAW) or <code>write()</code> (TCP) to send data.</li><li>Allocate an <code>skb</code> buffer in kernel-space memory.</li><li>Copy data from user-space memory to <code>skb</code> buffer (kernel space).</li><li>Insert <code>skb</code> in <code>sk_write_queue</code> of <a href="https://www.kernel.org/doc/htmldocs/networking/API-struct-sock.html" target="_blank" rel="noreferrer"><code>struct sock</code></a>.</li><li>Push out data from the queue and forward it to the IP layer.</li></ol><p><img src="`+r+'" alt="figure-2"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h4 id="procedure-for-incoming-packets" tabindex="-1">Procedure for incoming packets <a class="header-anchor" href="#procedure-for-incoming-packets" aria-hidden="true">#</a></h4><ol><li>An appl calls either <code>recvform()</code> (UDP, RAW) pr <code>read()</code> (TCP) to obtain data from socket data structure.</li><li>Call a non-blocing function call <code>io_local_deliver_finish</code> to retrieve <code>struck sock</code> of that packet and insert the received packet into flow&#39;s queue.</li><li>When the data is ready in the queue, notify the app taht data are available for receipt.</li><li>Then Remove data from queue corresponding to the flow into an <code>skb</code> space.</li><li>Finally, copy data from kernel-space memory to user-space one.</li></ol><p><img src="'+i+'" alt="figure-3"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h2 id="unreliable-protocol-udp" tabindex="-1">Unreliable Protocol: UDP <a class="header-anchor" href="#unreliable-protocol-udp" aria-hidden="true">#</a></h2><p>UDP is used to transmit <strong>urgent</strong> or <strong>real-time</strong> data.</p><ol><li>Unreliable connectionless protocol <ul><li>Does not provide <strong>reliability</strong> and <strong>rate control</strong>.</li></ul></li><li>Stateless protocol <ul><li>Sending and receiving of a segment is <strong>independent</strong> of that of any other segments, thus packets may arrive out-of-order due to different route.</li></ul></li></ol><h3 id="udp-header-format" tabindex="-1">UDP header format <a class="header-anchor" href="#udp-header-format" aria-hidden="true">#</a></h3><p>UDP header supports <strong>addressing</strong> and error detection. A <strong>socket pair</strong> of 5-tuple</p><ol><li>src IP addr</li><li>src port</li><li>dst IP addr</li><li>dst port</li><li>transport portocol</li></ol><p>uniquely identifies a communication flow.</p><ul><li>UDP header <ul><li>source/destination <strong>port numbers</strong></li></ul></li><li>IP header (not shown here) <ul><li>source/destination <strong>IP addresses</strong> and <strong>transport protocol</strong></li></ul></li></ul><table><tr><td>0</td><td>15</td></tr><tr><td>source port number</td><td>destination port number</td></tr><tr><td>UDP length (of data)</td><td>UDP checksum (optional)</td></tr><tr><td colspan="2">data (if any)</td></tr></table><p>Socket pair is <strong>full-duplex</strong>, meaning that data can be transmitted through the socket connection in <em>both directions simultaneously</em>, whereas half-duplex means one direction at a time.</p><h4 id="udp-header-supports-addressing-and-error-detection" tabindex="-1">UDP header supports addressing and <strong>error detection</strong> <a class="header-anchor" href="#udp-header-supports-addressing-and-error-detection" aria-hidden="true">#</a></h4><ul><li>UDP header provides a 16-bit <strong>checksum</strong> for data integrity, but it can be disabled by setting the chekcsum field to zero.</li><li>UDP receivers will <em>drop the datagrams</em> whose checksum field does not match the result they calculated <em>(without retransmission)</em></li></ul><p>UDP checksum field stores <strong>1&#39;s complement</strong> of the sum over all 16-bit words in both <em>header</em> and <em>payload</em> (not including itself obviously). We&#39;ve already cover the 1&#39;s complement checksum above.</p><p><strong>Cross-layer checking</strong> UDP checksum also covers a 96-bit pseudo header, which consists of four fields in IP header</p><ol><li>Source IP address, 32 bits</li><li>Destination IP address, 32 bits</li><li>Protocol, 16 bits</li><li>Total length, 16 bits</li></ol><h2 id="reliable-protocol-tcp" tabindex="-1">Reliable Protocol: TCP <a class="header-anchor" href="#reliable-protocol-tcp" aria-hidden="true">#</a></h2><ul><li><a href="#connection-management">Connection managemnet</a></li><li><a href="#reliability-of-data-transfers">Reliability of data transfers</a></li><li><a href="#flow-control-and-congestion-control">Flow control and congestion control</a></li><li><a href="#header-format-and-timer-management">Header format and timer management</a></li></ul><h3 id="connection-management" tabindex="-1">Connection management <a class="header-anchor" href="#connection-management" aria-hidden="true">#</a></h3><p>In the Internet, packets are sent to their destinations in a <strong>store-and-forward</strong> manner</p><ul><li>TCP restricts the <strong>maximum lifetime</strong> of a packet to 120 seconds.</li></ul><p><img src="'+l+'" alt="figure-4"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><ul><li>TCP adopts a <strong>Three-way handshake protocol</strong> for connection establishment and termination.</li></ul><p>When a client would like to make a request to the server, a connection must be first established. The client would sent a <strong>SYN</strong> (synchronize) to the server. If the server do receive the SYN, it would reply with an <strong>ACK</strong> acknowledgement. However, the server will also send another SYN, and if the client receive this SYN, it also reply with a ACK. When the server receive this ACK, at this moment, the connection is finally established. All of these above is so called <strong>three-way handshaking</strong>.</p><p>You may ask, why do we need so many SYNs and ACKs? Why don&#39;t we just use 2-way handshaking? There&#39;re many reasons for it, one of them is to enable <strong>full-duplex</strong>. We&#39;ll talk about other reasons later.</p><p><img src="'+c+'" alt="figure-5"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h4 id="various-connection-cases" tabindex="-1">Various connection cases <a class="header-anchor" href="#various-connection-cases" aria-hidden="true">#</a></h4><p><strong>TCP state transition diagram</strong> It&#39;s useful to get familiar with these states in order to understand various cases below.</p><p><img src="'+d+'" alt="figure-6"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><strong>Normal case</strong></p><p><img src="'+p+'" alt="figure-7"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p>Note that during establishment (right), the client establishes the connection upon receving the first ACK, whereas the server establishes one upon the second ACK, which is one of the reason of using 3-way handshaking.</p><p><strong>Special case: simultaneous open or close</strong></p><p>Sometimes, the server would actively connect with the client also by sending a SYN. However, if the client also send a SYN at the same time, a <strong>simultaneous open</strong> happends. With the design of the state transition, TCP can still successfully establishes connection. The same logic can be applied on the case of termination.</p><p><img src="'+h+'" alt="figure-8"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h4 id="loss-in-establishment" tabindex="-1">Loss in establishment <a class="header-anchor" href="#loss-in-establishment" aria-hidden="true">#</a></h4><p><strong>Case 1: SYN sent by the client is lost</strong></p><p>TCP uses <strong>timeout</strong> to get out.</p><p><img src="'+u+'" alt="figure-9"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><strong>Case 2: SYN sent by the server is lost</strong></p><p><img src="'+g+'" alt="figure-10"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p>Why does the server send <strong>RST</strong> even if the client is closed, we shall see the answer in the next case.</p><p><strong>Case 3: ACK of SYN sent by the client is lost</strong></p><p><img src="'+m+`" alt="figure-11"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p>With the same state transition design, it can handle both case 2 &amp; 3 regardless of whether the client is closed or established.</p><h4 id="tcp-state-implementation" tabindex="-1">TCP state implementation <a class="header-anchor" href="#tcp-state-implementation" aria-hidden="true">#</a></h4><p><strong>In <code>struct sock</code></strong></p><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">unsigned</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">char</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;"> //connection state</span></span>
<span class="line"></span></code></pre></div><p>The <code>volatile</code> keyword prevent an optimizing compiler from optimizing away subsequent reads or writes and thus incorrectly reusing a state value or omitting writes. In other words, the CPU has to take the value from the memory every time the variable is used instead from the register. Because the register might not be synchronized with the memory. <strong>State names</strong></p><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">char</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">statename</span><span style="color:#C792EA;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Unused</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">    </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Established</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">  </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Syn Sent</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">     </span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Syn Recv</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">  </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Fin Wait 1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">   </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Fin Wait 2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">   </span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Time Wait</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Close</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">        </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Close Wait</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">   </span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Last ACK</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">  </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Listen</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">       </span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Closing</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><h3 id="reliability-of-data-transfers" tabindex="-1">Reliability of data transfers <a class="header-anchor" href="#reliability-of-data-transfers" aria-hidden="true">#</a></h3><h4 id="data-integrity-and-reliability" tabindex="-1">Data Integrity and reliability <a class="header-anchor" href="#data-integrity-and-reliability" aria-hidden="true">#</a></h4><ul><li>Data integrity <ul><li>Successfully received packets are exactly the same as they are transmitted.</li></ul></li><li>Data reliability <ul><li><strong>Every</strong> transmitted packet is successfully <strong>received</strong> and is exactly the same as the original transmitted one.</li></ul></li></ul><p><strong>In TCP</strong></p><ul><li>Per-segment integrity <ul><li>Checksum (same as UDP but mandatory)</li></ul></li><li>Per-flow reliability <ul><li>Sequence number and acknowledgment (<strong>ACK</strong>)</li></ul></li></ul><h4 id="per-flow-reliability" tabindex="-1">Per-flow reliability <a class="header-anchor" href="#per-flow-reliability" aria-hidden="true">#</a></h4><ul><li>The <strong>sequence number</strong> of a segment is the sequence number of its first data byte (octet) <ul><li>TCP header has a field of 32-bit sequence number.</li><li>TCP sender numbers and tracks its data octets that have been <strong>sent</strong> and wait for their <strong>ACKs</strong></li></ul></li><li>On receiving a data segment, TCP receiver replies with an <strong>ACK</strong> that carries an acknowledgment number indicating <ol><li>The expected sequence number of the <strong>next</strong> data segment (the fisrt of the <strong>unACKed</strong> segments)</li><li>All data octets preceding (not including) the specified ACK number have been successfully received</li></ol></li></ul><h4 id="acknowledgment" tabindex="-1">Acknowledgment <a class="header-anchor" href="#acknowledgment" aria-hidden="true">#</a></h4><p>There are three popular types of ACKs. Assume the sender has sent the following sequence</p><p><span style="font-size:large;color:blue;">1 2 3 <span style="text-decoration:line-through;color:red;">4 5</span> 6</span></p><p>Where the strikethroughed/red denotes the lost sequence, i.e. not received by the receiver.</p><ol><li>Selective ACK, <strong>adopted by IP</strong><ul><li>Indicate that the receiver has received a segment whose sequence number is <strong>equal</strong> to the specified ACK number</li><li>ACK: <span style="color:blue;">1 2 3 6</span></li></ul></li><li>Cumulative ACK, <strong>adopted by TCP</strong><ul><li>Indicate that all previous data octets preceding the specified ACK number have been received</li><li>ACK: <span style="color:blue;">4</span></li></ul></li><li>Negative ACK <ul><li>Indicate that the receiver has <strong>not</strong> received a segment whose sequence number is <strong>equal</strong> to the specified ACK number</li><li>ACK: <span style="color:blue;">45</span></li></ul></li></ol><h4 id="tcp-culmulative-ack" tabindex="-1">TCP culmulative ACK <a class="header-anchor" href="#tcp-culmulative-ack" aria-hidden="true">#</a></h4><p>Culmulative ACK can solve the following problem</p><ol><li>Packet loss</li><li>Delay</li><li>ACK loss</li><li>Out of order sequence number</li></ol><p><img src="`+f+'" alt="figure-12"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><img src="'+b+`" alt="figure-13"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><h3 id="flow-control" tabindex="-1">Flow control <a class="header-anchor" href="#flow-control" aria-hidden="true">#</a></h3><ul><li>Flow control: TCP sender avoid to <strong>overflowing its receiver&#39;s buffer</strong> (possibly depends on the receiving host&#39;s memory size)</li><li>Congestion control: TCP sender acoid to overburdening the <strong>shared network</strong> reseource</li></ul><h4 id="tcp-window-size" tabindex="-1">TCP window size <a class="header-anchor" href="#tcp-window-size" aria-hidden="true">#</a></h4><p>The bandwidth of TCP is determined by its window size</p><ul><li><strong>RWND</strong>: <strong>r</strong>eceiver <strong>w</strong>i<strong>nd</strong>ow size <ul><li>advertised by the <strong>receiver</strong></li></ul></li><li><strong>CWND</strong>: <strong>c</strong>ongestion <strong>w</strong>i<strong>nd</strong>ow size <ul><li>calculated by the <strong>sender</strong></li></ul></li></ul><p>In the real implementation, the window size is counted in <strong>bytes</strong> (rather in segments). TCP receiver advertised the buffer size (in bytes) into the <strong>16-bit window size</strong> in TCP header.</p><div class="tip custom-block"><p class="custom-block-title">TCP Window Size</p><p>TCP window size = min(RWND, CWND)</p></div><h4 id="tcp-flow-control" tabindex="-1">TCP flow control <a class="header-anchor" href="#tcp-flow-control" aria-hidden="true">#</a></h4><p>Sliding-window mechanism for flow control</p><ul><li>Sender maintains a sending window to record the starting and ending sequence numbers of data segments being sent.</li><li>Segements sent but <strong>not ACKed</strong> are kept in a <strong>retransmission buffer</strong>.</li></ul><p><strong>Pseudo code</strong></p><div class="language-sh"><button class="copy"></button><span class="lang">sh</span><pre><code><span class="line"><span style="color:#A6ACCD;">SWS = send window size</span></span>
<span class="line"><span style="color:#A6ACCD;">LAR = last acknowledgement received</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> the sender has data to send</span></span>
<span class="line"><span style="color:#A6ACCD;">    Transmit up to </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">SWS packets starting from </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">LAR</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;"># Send the whole window</span></span>
<span class="line"><span style="color:#A6ACCD;">endif</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> an </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">ACK arrives</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">ACK </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">LAR</span></span>
<span class="line"><span style="color:#A6ACCD;">        LAR = </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">ACK </span><span style="color:#676E95;"># The window is slid</span></span>
<span class="line"><span style="color:#A6ACCD;">    endif</span></span>
<span class="line"><span style="color:#A6ACCD;">endif</span></span>
<span class="line"></span></code></pre></div><p><img src="`+y+'" alt="figure-14"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><strong>Example</strong></p><div class="tip custom-block"><p class="custom-block-title">Normal Case</p><p>The green boxes represent segments that just arrived and about to send the ACK. In this cas, the window is slid by on segment at a time. <img src="'+w+'" alt="figure-15"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote></div><div class="warning custom-block"><p class="custom-block-title">Out-Of-Sequence Case</p><p>In this case, the window may be slid by multiple segments <img src="'+C+'" alt="figure-16"><img src="'+k+'" alt="figure-17"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote></div><h3 id="congetsion-control" tabindex="-1">Congetsion control <a class="header-anchor" href="#congetsion-control" aria-hidden="true">#</a></h3><p>TCP sender infers network congestion in a try-and-error fashion. It detects the <strong>loss</strong> events of data segments. If there&#39;s loss, it <strong>slows</strong> down its transmission rate to avoid network congestion.</p><h4 id="tcp-tahoe" tabindex="-1">TCP Tahoe <a class="header-anchor" href="#tcp-tahoe" aria-hidden="true">#</a></h4><p>TCP Tahoe uses a <strong>congestion window</strong> (cwnd) to control the amount of transmitted data in one RTT (round-trip time, the time it takes from the sender to the receiver and ACK back to the sender). Maximum value of cwnd is contrained by maximum window <strong>mwnd</strong>.</p><ul><li>cwnd: congestion window</li><li>ssth: slow start threshold</li></ul><p><img src="'+v+'" alt="figure-18"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><strong>Slow start</strong></p><p>Initially, <code>cwnd=1</code>. And <code>cwnd++</code> upoon receiving <strong>1 ACK</strong>. This results in a <strong>exponential</strong> growth. The below example assume no sequence is lost.</p><table><thead><tr><th>cwnd (sent)</th><th>ACK</th><th>Increment (= 1*ACK)</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2 (1+1)</td><td>2</td><td>2</td></tr><tr><td>4 (2+2)</td><td>4</td><td>4</td></tr><tr><td>8</td><td>8</td><td>8</td></tr><tr><td>16</td><td>16</td><td>16</td></tr></tbody></table><p>Until...</p><ul><li>No loss <ul><li>When <code>cwnd</code> reaches <code>ssth</code>, enter the <strong>congestion avoidance</strong> state.</li></ul></li><li>Sequence lost <ul><li>If <strong>triple duplicate ACKs</strong> (because of the lost sequence) are received, enter the <strong>fast retransmit</strong> state</li><li>If no ACK is received before <strong>timeout</strong>, enter the <strong>retransmission timeout</strong> state and reset <code>cwnd=1</code></li></ul></li></ul><p><strong>Congestion avoidance</strong></p><p><code>cwnd = cwnd + 1/cwnd</code> upon receiving <strong>1 ACK</strong>. This results in a <strong>linear</strong> growth.</p><table><thead><tr><th>cwnd (sent)</th><th>ACK</th><th>Increment (= (1/cwnd)*ACK)</th></tr></thead><tbody><tr><td>16</td><td>16</td><td>1/16*16 = 1</td></tr><tr><td>17 (16+1)</td><td>17</td><td>1/17*17 = 1</td></tr><tr><td>18</td><td>18</td><td>1</td></tr><tr><td>19</td><td>19</td><td>1</td></tr></tbody></table><p>Until sequence lost and same as <strong>slow start</strong> state...</p><ul><li><strong>triple duplicate ACKs</strong>: enter the <strong>fast retransmit</strong> state</li><li><strong>timeout</strong>: enter the <strong>retransmission timeout</strong> state and reset <code>cwnd=1</code></li></ul><p><strong>Fast retransmit</strong> Fast retransmit aims at sending the lost packet <strong>immediately</strong> without waiting for the timeout</p><ul><li>Duplicate ACKs may be caused by <ol><li>A lost packet</li><li>An out-of-order packet</li></ol></li><li>The sender assumes that packet loss occurs upon receiving 3 or more duplicate ACKs</li><li>After successfully retransmitting the lost packet, set <code>ssth=cwnd/2</code> and reset <code>cwnd=1</code> then go back to <strong>slow start</strong> state.</li></ul><p><strong>Retransmission timeout</strong> If a timeout occurs, the sender sets <code>ssth=cwnd/2</code> and return to the slow start state.</p><p><strong>Example</strong></p><p><img src="'+D+'" alt="figure-19"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p>If you&#39;re wandering what is <code>awnd</code>, see <a href="#awnd">here</a></p><h4 id="tcp-reno" tabindex="-1">TCP Reno <a class="header-anchor" href="#tcp-reno" aria-hidden="true">#</a></h4><p>Add a new state: <strong>fast recovery</strong> state <img src="'+A+'" alt="figure-20"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><strong>Fast recovery</strong> When fast retransmit is performed, the sender retransmit the lost packet sets</p><ul><li><code>ssth = cwnd/2</code></li><li><code>cwnd = ssth+3</code><ul><li>Because 3 duplicate ACKs will trigger 3 <code>cwnd++</code> in fast recovery state</li></ul></li></ul><p>Then enter the <strong>fast recovery</strong> state to transmit new packets if allowed. In this state, <code>cwnd++</code> upon receiving an ACK.</p><p>When ACK of the <strong>lost packet</strong> is received, set <code>cwnd=ssth</code> and go back to <strong>congestion avoidance</strong> state.</p><p><strong>Example</strong></p><h5 id="awnd" tabindex="-1">awnd <a class="header-anchor" href="#awnd" aria-hidden="true">#</a></h5><p><img src="'+F+'" alt="figure-21"></p><ul><li><code>snd.una</code>: the first sequence number of the sent but not ACKed packets <ul><li>The receiver always ACK with the sequence number of the earilest not-received packet (culmulative), i.e., first of the unACKed (not-received) packets.</li></ul></li><li><code>snd.nxt</code>: the sequence number of the next packet to sent</li></ul><p>TCP use <code>cwnd-awnd</code> to count <strong>outstanding</strong> packets, i.e. number of packets to send in order to fill the window. In other words, send the next packet if <code>awnd</code> &lt; <code>cwnd</code>, otherwise stop.</p><p><img src="'+P+'" alt="figure-22"></p><p>Notice that since the <code>cwnd</code> only reduced to <code>ssth</code> instead of 1, and <code>cwnd++</code> upon receiving an ACK, the sender can send new packets during recovery state.</p><p><strong>Tahoe vs. Reno</strong></p><p><img src="'+q+'" alt="figure-23"></p><blockquote><p>Image credit to Professor Wang&#39;s slides</p></blockquote><p><img src="'+T+'" alt="figure-24"></p><blockquote><p>Image credit to Computer Networking: A Top-down Approach, 7th Edition</p></blockquote><h3 id="header-format-and-timer-management" tabindex="-1">Header format and timer management <a class="header-anchor" href="#header-format-and-timer-management" aria-hidden="true">#</a></h3><table><tr><th colspan="16">0</th><th colspan="16">15</th></tr><tr><td colspan="16">source port number</td><td colspan="16">destination port number</td></tr><tr><td colspan="32">32-bit sequence number</td></tr><tr><td colspan="32">32-bit acknowledgement number</td></tr><tr><td colspan="4">header length</td><td colspan="6">6-bit reserved</td><td colspan="1">U</td><td colspan="1">A</td><td colspan="1">P</td><td colspan="1">R</td><td colspan="1">S</td><td colspan="1">F</td><td colspan="16">window size</td></tr><tr><td colspan="16">TCP checksum</td><td colspan="16">urgent pointer</td></tr><tr><td colspan="32">option (if any)</td></tr><tr><td colspan="32">data</td></tr></table><ul><li>Since the length of options is variable, you need a <strong>header length</strong></li><li>TCP receiver should tell the sender about it&#39;s buffer length (rwnd, in bytes) via the <strong>window size</strong> slot in the header.</li></ul><h4 id="control-bits" tabindex="-1">Control bits <a class="header-anchor" href="#control-bits" aria-hidden="true">#</a></h4><ul><li>URG bit</li><li>ACK bit</li><li>PSH bit</li><li>RST bit</li><li>SYN and FIN bits</li></ul><p><strong>URG bit</strong></p><p>URG bit indicates that the 16-bit urgent pointer is valid.</p><ul><li>Urgent pointer is an offset from the first data byte in <strong>payload</strong>, which indicates the last urgent data type.</li><li>It facilitates the <strong>in-band signaling</strong> of a TCP connection <ul><li>E.g. Users use ^C to trigger an urgent signal to cancel an operation</li></ul></li></ul><p><strong>ACK bit</strong></p><p>ACK bit inidcates that the 32-bit acknowledgemnet number is valid. Acknowledgement number contains the next sequence number that the receiver is expecint to receive.</p><p><strong>PSH bit</strong></p><p>PSH bit asks the receiver to flush out the data in the receiver buffer immediately</p><p><strong>RST bit</strong></p><p>RST bit will reset a connection. Any host receiving an RST-set packet should immediately <strong>close</strong> the connection associated with that packet.</p><p><strong>SYN and FIN bits</strong></p><ul><li>SYN bit initializes a connection</li><li>FIN bit initializes that no more data will be sent hence close the connection on both sides.</li></ul><h4 id="options" tabindex="-1">Options <a class="header-anchor" href="#options" aria-hidden="true">#</a></h4><ul><li>End of option list</li><li>No operation</li><li>Maximum segment size</li><li>Window scale factor</li><li>Timestamp</li></ul><h4 id="timer" tabindex="-1">Timer <a class="header-anchor" href="#timer" aria-hidden="true">#</a></h4><table><thead><tr><th>Timer</th><th>Function</th></tr></thead><tbody><tr><td>Connection</td><td>If no response of the SYN after this timeout, the connection is aborted</td></tr><tr><td>Retransmission</td><td>TCP resends the data if unACKed or the timer expires</td></tr><tr><td>Delayed ACK</td><td>The receiver must wait till delayed ACK timeout to send the ACK, otherwise a ACK storm might happend</td></tr><tr><td>Persist</td><td>Solve a deadlock problem of <code>rwnd=0</code></td></tr><tr><td>Keepalive</td><td>Clear the idle connections</td></tr></tbody></table><p><strong>Persist timer</strong></p><p>A deadlock problem if <code>rwnd=0</code></p><ul><li>Receiver sends an ACK with a receiver window size of 0, which tells the sender to wait</li><li>Then the receiver advertises its updated window size, but the packet is <strong>lost</strong>.</li><li>So both the sender and receiver are waiting for each other to do someting</li></ul><p>TCP persist timer is used to prevent the above deadlock</p><ul><li>When sender receives an ACL with <code>rwnd=0</code>, it sets a persist timer</li><li>When the persist timer goes off and sender hasn&#39;t heard anything from the receiver, it transmits a <strong>probe</strong> to the receiver</li><li>The receiver can respond to the probe, which gives its window size</li><li>If the <code>rwnd</code> still equals zero, the sender sets another persist timer and keep waiting</li></ul><p><strong>Keepalive timer</strong></p><p>Keepalive timer keeps unnecessary resources from being allocated forever</p><ul><li>An empty packet is sent periodically over an idle connection, which should invoke <ul><li>an ACK from the receiver if it is still up</li><li>a reset by RST if it has been rebooted</li><li>a timeout if it is down (close connection)</li></ul></li></ul>',212),x=[I];function S(K,W,R,E,U,N){return s(),t("div",null,x)}const H=e(_,[["render",S]]);export{Y as __pageData,H as default};
